<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhenyu</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iszhenyu.me/"/>
  <updated>2016-09-07T10:11:18.000Z</updated>
  <id>http://iszhenyu.me/</id>
  
  <author>
    <name>zhenyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python中的datetime模块</title>
    <link href="http://iszhenyu.me/posts/2016-09-07-python%E4%B8%AD%E7%9A%84datetime%E6%A8%A1%E5%9D%97.html"/>
    <id>http://iszhenyu.me/posts/2016-09-07-python中的datetime模块.html</id>
    <published>2016-09-07T06:17:32.000Z</published>
    <updated>2016-09-07T10:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timedelta"><a href="#timedelta" class="headerlink" title="timedelta"></a>timedelta</h2><h3 id="timedelta的实例化"><a href="#timedelta的实例化" class="headerlink" title="timedelta的实例化"></a>timedelta的实例化</h3><p>一个<code>timedalta</code>对象代表了一个时间差，当两个<code>date</code>或<code>datetime</code>进行相减操作时会返回一个<code>timedelta</code>对象，或者，我们也可以手动对其进行实例化，其构造函数的原型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">datetime</span>.<span class="title">timedelta</span><span class="params">([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])</span></span></div></pre></td></tr></table></figure></p>
<p>其中，所有的参数都是可选的，并且默认为0，一般情况下，我们常用的是其中三个参数<code>days</code>、<code>seconds</code>、<code>microseconds</code>，如果我们传递了其他的几个参数值，python会帮助我们自动转换成上面三个参数，转换的规则是：</p>
<ul>
<li>1 millisecond（毫秒） 转换成 1000 microseconds（微秒）</li>
<li>1 minute 转换成 60 seconds</li>
<li>1 hour 转换成 3600 seconds</li>
<li>1 week转换成 7 days</li>
</ul>
<p>如果我们在实例化的时候直接传递的是上面三个参数值，那么也要注意下它们的取值范围：</p>
<ul>
<li>0 &lt;= microseconds &lt; 1000000</li>
<li>0 &lt;= seconds &lt; 3600*24 (一天的秒数)</li>
<li>-999999999 &lt;= days &lt;= 999999999</li>
</ul>
<p>那么，如果我们在传递这三个参数的时候超出了这个范围会有什么问题吗，答案是不一定，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = datetime.timedelta(seconds=<span class="number">86400</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.days</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.seconds</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>可以看到，如果超过范围，python是会帮我们自动转换的，但是如果<code>days</code>参数超出范围会有什么结果呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ee = datetime.timedelta(days=<span class="number">1000000000</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">OverflowError: days=<span class="number">1000000000</span>; must have magnitude &lt;= <span class="number">999999999</span></div></pre></td></tr></table></figure></p>
<p>所以，只有<code>days</code>是不能超出范围的，否则会抛出<code>OverflowError</code>异常。</p>
<p>在实例化的时候，参数不仅仅可以是整数，也可以是浮点数、正数或者负数，当参数为负数的时候，要特别注意，因为生成的样式也许与我们设想的不太一致<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = datetime.timedelta(microseconds=<span class="number">-1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.days, tmp.seconds, tmp.microseconds</div><div class="line">(<span class="number">-1</span>, <span class="number">86399</span>, <span class="number">999999</span>)</div></pre></td></tr></table></figure></p>
<p>所以，我们传递参数的时候，尽量避免传递负数的情况，同样，我们也应该极力避免传递的参数为浮点数，我们在使用的时候一般以秒作为单位就能满足99%的需求了。</p>
<h3 id="timedelta的运算"><a href="#timedelta的运算" class="headerlink" title="timedelta的运算"></a>timedelta的运算</h3><h4 id="操作"><a href="#操作" class="headerlink" title="+ 操作"></a><code>+</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = datetime.timedelta(seconds=<span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = datetime.timedelta(seconds=<span class="number">30</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1 + t2</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t3.seconds</div><div class="line"><span class="number">90</span></div></pre></td></tr></table></figure>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="- 操作"></a><code>-</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t4 = t1 -t2</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t4.seconds</div><div class="line"><span class="number">30</span></div></pre></td></tr></table></figure>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="* 操作"></a><code>*</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t5 = t1 * <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t5</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">120</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t6 = t1 * <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t6</div><div class="line">datetime.timedelta(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h4 id="或-操作"><a href="#或-操作" class="headerlink" title="/ 或 //操作"></a><code>/</code> 或 <code>//</code>操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 / <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">20</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 / <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">8</span>, <span class="number">571428</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 // <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">8</span>, <span class="number">571428</span>)</div></pre></td></tr></table></figure>
<p>注意这里的被除数不能是0，否则会抛出<code>ZeroDivisionError</code>。</p>
<h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &gt; t2</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &lt; t2</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == <span class="number">60</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 != <span class="number">60</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &gt; <span class="number">60</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: can<span class="string">'t compare datetime.timedelta to int</span></div></pre></td></tr></table></figure>
<p>可以看到，两个<code>timedelta</code>对象可以直接进行比较操作，而一个<code>timedelta</code>对象与一个非<code>timedelta</code>对象进行<code>==</code>或<code>!=</code>操作时总是返回<code>False</code>，而进行<code>&gt;</code>或<code>&lt;</code>操作则会抛出<code>TypeError</code>。</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>+t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>-t1</div><div class="line">datetime.timedelta(<span class="number">-1</span>, <span class="number">86340</span>)</div><div class="line"></div><div class="line">// 返回的格式为[D day[s], ][H]H:MM:SS[.UUUUUU]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(t1)</div><div class="line"><span class="string">'0:01:00'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(-t1)</div><div class="line"><span class="string">'-1 day, 23:59:00'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>repr(t1)</div><div class="line"><span class="string">'datetime.timedelta(0, 60)'</span></div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在2.7版本后，新增了一个方法<code>timedelta.total_seconds()</code>用于计算秒数，它等价于<code>(td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1.total_seconds()</div><div class="line"><span class="number">60.0</span></div></pre></td></tr></table></figure></p>
<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>一个<code>date</code>对象代表使用年、月、日表示的时间，我们可以只用年、月、日三个值直接构造一个<code>date</code>对象，且这三个参数缺一不可，它们的取值范围如下</p>
<ul>
<li>MINYEAR &lt;= year &lt;= MAXYEAR</li>
<li>1 &lt;= month &lt;= 12</li>
<li>1 &lt;= day &lt;= 给定年月的天数</li>
</ul>
<p>如果我们传递的参数超出这个范围，将会抛出<code>ValueError</code>异常。除了手动传入年、月、日来构造<code>date</code>对象外，系统还提供了静态方法，我们可以使用这些静态方法来方便的得到一个<code>date</code>对象</p>
<ul>
<li><p>date.today()<br>返回当前的本地时间，等价于<code>date.fromtimestamp(time.time())</code></p>
</li>
<li><p>date.fromtimestamp(timestamp)</p>
</li>
</ul>
<p>当得到<code>date</code>对象后，就可以直接访问它的年、月、日属性了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = date.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.year</div><div class="line"><span class="number">2016</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.month</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.day</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p>
<h3 id="运算与比较操作"><a href="#运算与比较操作" class="headerlink" title="运算与比较操作"></a>运算与比较操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>delta = timedelta(days=<span class="number">7</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future = today + delta</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">8</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future - delta</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future - today</div><div class="line">datetime.timedelta(<span class="number">7</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future &gt; today</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>date</code>可以作为字典的key，并且，所有的<code>date</code>对象都会被认为是<code>True</code>的，也就是 if date 这个判断永远是成立的。</p>
</blockquote>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p>date.replace(year, month, day)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">datetime.date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(day=<span class="number">26</span>)</div><div class="line">datetime.date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">26</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>date.weekday()<br>返回一周的礼拜几，用int值表示，从0开始</p>
</li>
<li>date.isoweekday()<br>返回一周的礼拜几，用int值表示，从1开始</li>
<li>date.isoformat()<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.isoformat()</div><div class="line"><span class="string">'2002-12-31'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><code>datetime</code>从字面意思上看是<code>date</code>和<code>time</code>的结合，而实际上也是包含了这两个对象的全部信息，我们可以手动构造<code>datetime</code>对象，也可以使用系统提供的静态方法，当我们手动构造的时候，必须要传入<code>year</code>、<code>month</code>和<code>day</code>三个参数，他们的取值范围与上面讲到的<code>date</code>对象一致。</p>
<p>我们在处理时间问题时，始终无法回避的是时区问题，在python中，使用<code>datetime.tzinfo</code>来表示时区，但这是一个抽象基类，python也并没帮我们实现任意的时区，因此，我们首先来看下在不涉及时区的时候<code>datetime</code>都有哪些用法，然后我们会创建一个本地时区，也就是东八区，来说明<code>datetime</code>如何与<code>tzinfo</code>结合使用。</p>
<h3 id="datetime对象的创建"><a href="#datetime对象的创建" class="headerlink" title="datetime对象的创建"></a>datetime对象的创建</h3><p>我们可以通过指定年月日的形式来手动创建一个<code>datetime</code>实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>cur = datetime(year=<span class="number">2016</span>, month=<span class="number">9</span>, day=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cur</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>也可以直接通过静态方法来获的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.today()</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">21</span>, <span class="number">810692</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.now()</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">34</span>, <span class="number">89763</span>)</div></pre></td></tr></table></figure></p>
<p>这两个方法都会返回一个本地当前时间，也就是上面的两个写法是等效的，但是要注意的是，<code>now()</code>方法可以传入时区信息，我们稍后再一起讨论。</p>
<p>除了上面的方法，我们还可以通过时间戳来获取一个对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.fromtimestamp(time.time())</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">65907</span>)</div></pre></td></tr></table></figure></p>
<p>我们这里同样暂不考虑时区的问题。<br>除了通过时间戳获取<code>datetime</code>实例外，我们还可以通过一个格式化的时间字符串来获得实例，这个方法同样是不带时区信息的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.strptime(<span class="string">'2016-09-02 18:00:00'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>既然一个<code>datetime</code>对象包含了<code>date</code>和<code>time</code>的所有信息，那么能不能通过这两对象来生成一个<code>datetime</code>实例呢，答案是肯定的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = date(year=<span class="number">2016</span>, month=<span class="number">9</span>, day=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = time(hour=<span class="number">18</span>, minute=<span class="number">14</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">datetime.time(<span class="number">18</span>, <span class="number">14</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.combine(d, t)</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">14</span>)</div></pre></td></tr></table></figure></p>
<p>现在<code>datetime</code>也有了，我们总要在它身上做点什么吧，能做什么呢？</p>
<h3 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h3><p>有了<code>datetime</code>对象之后，我们就可以获得对应的<code>date</code>和<code>time</code>对象了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = datetime.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.date()</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.time()</div><div class="line">datetime.time(<span class="number">18</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">304536</span>)</div></pre></td></tr></table></figure></p>
<p>那如果我希望得到下个月的今天，该怎么做呢？方法有多种，但是最方便的是直接把月份进行加一操作（不考虑跨年和日期超过月份最大值的情况），这个时候<code>replace</code>函数就派上用场了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month = today.replace(month=today.month+<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">304536</span>)</div></pre></td></tr></table></figure></p>
<p><code>replace()</code>方法允许我们对<code>datetime</code>的任意字段进行替换，并返回一个新的<code>datetime</code>对象，这个新的对象在其他字段上与原有对象保持一致。</p>
<p>除此之外，还有一个比较常用的方法<code>strftime()</code>，通过它可以格式化成我们希望的样式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"><span class="string">'2016-10-02 18:30:10'</span></div></pre></td></tr></table></figure></p>
<p>还有一种情况，是我们希望将一个<code>datetime</code>对象转成时间戳，很遗憾的是python并没直接提供这个方法，但是提供了一个<code>timetuple()</code>方法，它返回一个<code>time.struct_time</code>对象，通过它我们可以构造出时间戳了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd = datetime.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tt = time.mktime(dd.timetuple())</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> int(tt)</div><div class="line"><span class="number">1472816083</span></div></pre></td></tr></table></figure></p>
<h3 id="时区的定义"><a href="#时区的定义" class="headerlink" title="时区的定义"></a>时区的定义</h3><p>python中给我们提供了<code>datetime.tzinfo</code>这一抽象的基类，如果我们想使用时区，则必须继承这个类来实现自己的时区定义。我们先来看下都有哪些方法可能需要我们来实现</p>
<ul>
<li><code>tzinto.utcoffset(self, dt)</code> </li>
</ul>
<p>这个方法返回本地时间与UTC时间的时差，我们知道，我们国家使用的是东八区，也就是比世界协调时间（UTC）/格林尼治时间（GMT）快8小时的时区，因此我们可以如下实现这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def utcoffset(self, dt):</div><div class="line">    return timedelta(hours=8)</div></pre></td></tr></table></figure></p>
<ul>
<li><code>tzinfo.dst(self, dt)</code></li>
</ul>
<p>这个方法主要是考虑到一些采用夏令时的国家，在固定月份来调整时间，而我们国家是没有采用夏令时，所以直接返回0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def dst(self, dt):</div><div class="line">    return timedelta(0)</div></pre></td></tr></table></figure></p>
<p>而对于采纳了夏令时的国家，则需要把夏令时考虑进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def dst(self, dt):</div><div class="line">    # Code to set dston and dstoff to the time zone&apos;s DST</div><div class="line">    # transition times based on the input dt.year, and expressed</div><div class="line">    # in standard local time.  Then</div><div class="line"></div><div class="line">    if dston &lt;= dt.replace(tzinfo=None) &lt; dstoff:</div><div class="line">        return timedelta(hours=1)</div><div class="line">    else:</div><div class="line">        return timedelta(0)</div></pre></td></tr></table></figure></p>
<p>对于这些国家，我还要修改<code>utcoffset</code>函数，将夏令时的偏移量考虑进去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def utcoffset(self, dt):</div><div class="line">    return timedelta(hours=N) + self.dst(dt)</div></pre></td></tr></table></figure></p>
<ul>
<li><code>tzinfo.tzname(self, dt)</code></li>
</ul>
<p>这个方法用来返回时区的名称，没有太多可说的</p>
<p>一般情况下，我们只要实现上面三个方法就可以了，例如我们可以这样定义一个UTC时区和我们所在的东八区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ZERO = timedelta(0)</div><div class="line">HOUR = timedelta(hours=1)</div><div class="line"></div><div class="line">class UTC(tzinfo):</div><div class="line">    &quot;&quot;&quot;UTC&quot;&quot;&quot;</div><div class="line"></div><div class="line">    def utcoffset(self, dt):</div><div class="line">        return ZERO</div><div class="line"></div><div class="line">    def tzname(self, dt):</div><div class="line">        return &quot;UTC&quot;</div><div class="line"></div><div class="line">    def dst(self, dt):</div><div class="line">        return ZERO</div><div class="line"></div><div class="line"></div><div class="line">class GMT8(tzinfo):</div><div class="line">    &quot;&quot;&quot;东八区&quot;&quot;</div><div class="line"></div><div class="line">    def utcoffset(self, dt):</div><div class="line">        return HOUR * 8</div><div class="line"></div><div class="line">    def tzname(self, dt):</div><div class="line">        return &apos;GMT-8&apos;</div><div class="line"></div><div class="line">    def dst(self, dt):</div><div class="line">        return ZERO</div></pre></td></tr></table></figure></p>
<p>除了我们自己来定义时区外，我们还可以使用<code>pytz</code>这个模块，通过<code>easy_install</code>命令直接安装即可。</p>
<h3 id="datetime与时区的结合使用"><a href="#datetime与时区的结合使用" class="headerlink" title="datetime与时区的结合使用"></a>datetime与时区的结合使用</h3><p>我们上面已经介绍了在不考虑时区因素的时候，<code>datetime</code>的一些简单用法，接下来看下加入时区后，有哪些不一样的地方，以及我们需要注意的地方。</p>
<p>我们在上面提到了类方法<code>now</code>，在不考虑时区的时候，它的作用和类方法<code>today</code>基本是一致的，我们也可以在使用<code>now</code>的时候传递一个<code>tzinfo</code>，如下的两种方式是等效的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">today = datetime.today()</div><div class="line">today = today.replace(tzinfo=GMT8())</div><div class="line">// 等效于</div><div class="line">today = datetime.now(GMT8())</div></pre></td></tr></table></figure></p>
<p>除了<code>now()</code>方法外，系统还提供了<code>utcnow()</code>方法，这个方法没有参数，返回的是UTC的时间，但是要注意的是，这个方法创建的<code>datetime</code>对象同样是不带时区信息的。</p>
<p>到目前为止，我们都还不知道时区到底有什么作用，假设说我们现在有这样的需求：在数据库中记录的时间全部采用UTC时间，而在展示的时候需要转换成本地时间。我们在查库后，一些ORM（例如：SQLAlchemy）会自动帮我们将时间值转化成<code>datetime</code>对象，但这些<code>datetime</code>都是不带时区信息的，如果我们想转化成本地时间则必须要创建本地的时区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">today = datetime.utcnow()</div><div class="line">today = today.replace(tzinfo=UTC())</div><div class="line">print today //2016-09-06 06:47:42.665574+00:00</div><div class="line"></div><div class="line">today = today.astimezone(GMT8())</div><div class="line">print today //2016-09-06 14:47:42.665574+08:00</div></pre></td></tr></table></figure></p>
<p>如上所示，系统提供了<code>datetime.astimezone(tz)</code>方法，使用这个方法可以在各个时区之间来回转换时间。这里有两点需要注意：</p>
<ul>
<li>如果<code>datetime</code>对象本身没有包含时区信息，调用这个方法会抛出<code>ValueError</code>，并提示<code>astimezone() cannot be applied to a naive datetime</code></li>
<li><code>replace(tzinfo=...)</code>方法只会替换<code>tzinfo</code>的值，并不会更改时分秒等时间信息</li>
</ul>
<p>最后，还有两个通过时间戳获取<code>datetime</code>的类方法，<code>datetime.fromtimestamp(timestamp[, tz])</code>和<code>datetime.utcfromtimestamp(timestamp)</code>，<code>utcfromtimestamp</code>得到的是一个UTC时间，并且不带<code>tzinfo</code>信息，除此之外，两者并无太大区别。</p>
<p>到这里，<code>datetime</code>模块的大部分方法就介绍完了，还有一些我们不是很常用的方法，大家可以自行看看文档了解下就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timedelta&quot;&gt;&lt;a href=&quot;#timedelta&quot; class=&quot;headerlink&quot; title=&quot;timedelta&quot;&gt;&lt;/a&gt;timedelta&lt;/h2&gt;&lt;h3 id=&quot;timedelta的实例化&quot;&gt;&lt;a href=&quot;#timedelta的实例
    
    </summary>
    
    
      <category term="python" scheme="http://iszhenyu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB索引</title>
    <link href="http://iszhenyu.me/posts/2016-08-30-MongoDB%E7%B4%A2%E5%BC%95.html"/>
    <id>http://iszhenyu.me/posts/2016-08-30-MongoDB索引.html</id>
    <published>2016-08-30T15:17:32.000Z</published>
    <updated>2016-08-30T15:18:08.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="mongo" scheme="http://iszhenyu.me/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>Android中与js进行交互</title>
    <link href="http://iszhenyu.me/posts/2016-07-01-Android%E4%B8%AD%E4%B8%8Ejs%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html"/>
    <id>http://iszhenyu.me/posts/2016-07-01-Android中与js进行交互.html</id>
    <published>2016-07-01T09:53:49.000Z</published>
    <updated>2016-09-07T06:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发Android应用的时候，很多的时候需要跟网页打交道，假如我们现在在做一个外卖app，在app首页会有一个轮询的广告位，我们点击其中一项会跳转至一个wap网页，在这个网页里可能会有几个餐厅的推广信息，在用户点击某个餐厅后，我们希望跳出wap页面展示餐厅的详情，这个时候就需要用到js调用java代码来实现了。再或者，如果我们需要在wap页中进行分享可能也需要用js调用java代码来执行分享的操作。类似这样的场景很多，如果我们需要实现这种功能，就要了解java和js之间的交互的方法。</p>
<h2 id="WebView的使用"><a href="#WebView的使用" class="headerlink" title="WebView的使用"></a>WebView的使用</h2><p>我们在Android中如果希望展示一个网页，基本上都会使用WebView这个组件，它的基本使用也很简单，假如我们希望加载一下百度首页，可以像下面这样写： 首先在layout文件中进行声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    &gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">WebView</span> </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在java文件中进行使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WebView webView = (WebView) findViewById(R.id.web_view);</div><div class="line">webView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</div></pre></td></tr></table></figure>
<p>同时，WebView还允许我们对一些默认设置进行修改，例如，我们希望启动对javascript的支持并且可以进行缩放，就需要做如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 启用javascript</span></div><div class="line">webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//是否可以缩放</span></div><div class="line">webView.getSettings().setSupportZoom(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setBuiltInZoomControls(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; </div><div class="line">    getSettings().setDisplayZoomControls(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们想要在页面加载的时候处理各种通知、请求事件，或者监听页面的加载进度等，就需要用到另外两个类：WebViewClient 和 WebChromeClient。其中，WebViewClient 主要用来监听通知或请求事件，我们在开发中可能会用到的方法主要是下面几个：</p>
<ul>
<li>onPageStarted</li>
<li>onPageFinished</li>
<li>onReceivedError</li>
<li>shouldOverrideUrlLoading</li>
</ul>
<p>而 <code>WebChromeClient</code> 则用来处理javascript、网站图标、网站title和加载进度等，我们在使用微信时，如果打开一个网页，会看到它的上面有一条绿色的进度条，这个功能就是通过重写 <code>WebChromeClient</code> 的 <code>onProgressChanged</code>方法来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebClient</span> <span class="keyword">extends</span> <span class="title">WebChromeClient</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(WebView view, <span class="keyword">int</span> newProgress)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (newProgress == <span class="number">100</span>) &#123; </div><div class="line">            mProgressBar.setVisibility(GONE); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">if</span> (mProgressBar.getVisibility() == GONE) &#123; </div><div class="line">                mProgressBar.setVisibility(VISIBLE); </div><div class="line">            &#125; </div><div class="line">            mProgressBar.setProgress(newProgress);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">super</span>.onProgressChanged(view, newProgress); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，WebView还提供了直接运行javascript的功能，例如，我们可以简单的弹出一个对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.loadUrl(<span class="string">"javascript:alert(\"提示信息！\");"</span>);</div></pre></td></tr></table></figure>
<p>当然，如果我们想要执行js，那么必须满足两个条件，第一个是在设置中开启javascript支持，即需要调用<code>setJavascriptEnabled(true)</code>，第二个是需要设置<code>WebChromeClient</code>，两者缺一不可。</p>
<p>在一些比较复杂的场景下，我们要做的不再是简单的显示一个页面而已，大多时候，我们更希望通过javascript来访问app内的一些数据，或者与app进行交互。我们尝试定义这样一个组件，希望可以通过它来达到我们的目的，我们暂且对这样的组件起名为<code>WebViewJavascriptBridge</code>。</p>
<h2 id="WebViewJavascriptBridge设计思路"><a href="#WebViewJavascriptBridge设计思路" class="headerlink" title="WebViewJavascriptBridge设计思路"></a>WebViewJavascriptBridge设计思路</h2><p>根据第二节的介绍，对于第一种情况，也就是通过java来调用javascript代码，系统已经帮我们实现好了，但是第二种情况系统却没有直接提供实现。 尽管如此，我们可以考虑是否能在 <code>WebViewClient</code> 或 <code>WebChromeClient</code> 中寻得突破口。在 <code>WebViewClient</code> 中存在这样一个方法: <code>shouldOverrideUrlLoading(WebView view, String url)</code>，在这个方法的注释中是这样说的：</p>
<blockquote>
<p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView.</p>
</blockquote>
<p>也就是说，对于在WebView中的每个请求，我们都是有机会对其进行拦截的，并且接管本次请求。 我们比较熟悉的是通过一个url来访问页面，比如我们在访问美团网的时候，它的一个团购单的url可能是这个样子 <code>http://bj.meituan.com/deal/25709595.html</code>，而url本身是可以携带一些信息的，上面这个url还不是很明显，如果我们换种写法，你就会看的更清楚些 <code>http://bj.meituan.com/?deal=25709595</code>当然这个链接并不能正常访问到团购页，这里只是做个示意，也就是说我们是可以通过这种param的形式来传递一些数据的。 而我们又可以在 <code>WebViewClient</code> 中对这个请求进行拦截，在拦截方法中我们是能够拿到本次请求的url中所传递过来的数据的，根据这些请求过来的数据，就可以执行本地java代码来处理了，处理完毕后，通过WebView又可以通过回调javascript的方式来返回结果。 以上就是我们实现 <code>WebViewJavascriptBridge</code> 的主要思路了，当然在具体实现的时候会有一些细节，这个我们在下一节具体实现的时候再继续探讨。<br>总结一下，1、java调用javascript可以直接调用。2、javascript调用java需要用到 <code>WebViewClient</code>。我们用下图更直观的表示下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2368004-9ab4b678dc70ba52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java与javascript交互示意.jpg"></p>
<h2 id="WebViewJavascriptBridge具体实现"><a href="#WebViewJavascriptBridge具体实现" class="headerlink" title="WebViewJavascriptBridge具体实现"></a>WebViewJavascriptBridge具体实现</h2><p>我们知道，一个标准的URL的格式应该是下面这个样子：</p>
<blockquote>
<p>protocol://hostname[:port]/path/[;parameters][?query]#fragment</p>
</blockquote>
<p>我们在访问页面的时候，用到的最多的协议就是<code>http</code>和<code>https</code>了，除了这两个协议外，还有<code>file</code>、<code>ftp</code>等等。这里我们自己来定义一个协议名称，所有javascript调用java的代码都走这个协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CUSTOM_PROTOCOL_SCHEME = <span class="string">"wvjbscheme"</span>; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCorrectProtocolScheme</span><span class="params">(String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(url)) &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> url.startsWith(CUSTOM_PROTOCOL_SCHEME + <span class="string">"://"</span>);   </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的好处就是，我们在对请求进行拦截后，可以更方便的分辩出哪些是需要自己处理的，而对哪些正常的网络请求放行。因此，我们可以定义一个<code>WebViewClient</code>的子类，并重写它的<code>shouldOverrideUrlLoading</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> WebViewJsBridgeBase base; </div><div class="line">    <span class="keyword">private</span> WebViewClient mWebViewClient; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            url = URLDecoder.decode(url, <span class="string">"UTF-8"</span>); </div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">            <span class="comment">// do nothing </span></div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">            ... </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">return</span> mWebViewClient.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们会去判断是否是我们自定义的协议，如果不是还会判断mWebViewClient是否为空，这里为什么还要定义一个WebViewClient呢？原因也很简单，<code>WebView</code>只能设置一个<code>WebViewClient</code>，我们这里已经定义了<code>WebViewClient</code>如果用户还需要自己定义怎么办呢？所以这里持有了一个用户自定义的<code>WebViewClient</code>，通过这个client就可以将一些事件转发出去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            mWebViewClient.onPageStarted(view, url, favicon); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">super</span>.onPageStarted(view, url, favicon); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，我们回到Bridge的实现问题上来。在一个页面加载完毕后，如果我们想使用javascript来调用java，那么前期的一些准备工作是必不可少的，因为我们这里说的javascript调用java并不是将javascript代码转化为java执行，而更像是一种曲线救国的方式，因此，至少我们要约定一下，javascript的哪个方法可以调用java对应的哪个方法，也就是我们对其进行一些初始化操作。</p>
<p>我们将java可以处理的每个问题抽象为一个Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBHandler</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>WVJBResponseCallback</code>也是一个接口，当<code>Handler</code>处理完毕后就是通过这个<code>callback</code>来进行回调给javascript端的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBResponseCallback</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(String responseData)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们定义的这两个接口里面，数据是按照String的格式进行传输的，因为javascript天生支持json，因此，对于一些复杂的数据类型，都可以转化为json字符串。</p>
<p>我们的初始化操作就包括注册这些Handler，也就是声明java端可以处理哪些问题，因为会有多个Handler，也就会有多个Callback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    Map&lt;String, WVJBResponseCallback&gt; responseCallbacks; </div><div class="line">    Map&lt;String, WVJBHandler&gt; messageHandlers; </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridge</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String handlerName, WVJBHandler handler)</span> </span>&#123; </div><div class="line">        base.messageHandlers.put(handlerName, handler); </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到目前为止，我们一直都是在讲java端的一些实现，那在js端到底要怎么样才能调用我们定义好的Handler呢？</p>
<p>通过上面的介绍，如果希望调用java代码，那么必须发起一个请求，在页面中我们发起请求的方式有几种，最常规的是点击一个链接进行跳转，还可以通过javascript来发起一个ajax请求，除此之外，我们还可以借助iframe，就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">WVJBIframe.style.display = <span class="string">'none'</span>;</div><div class="line">WVJBIframe.src = <span class="string">'wvjbscheme://__BRIDGE_LOADED__'</span>;</div><div class="line"><span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</div></pre></td></tr></table></figure>
<p>我们在原页面里面添加了一个隐藏的iframe元素，所有需要跟java交互的请求都是通过改变这个iframe的src属性来实现的。</p>
<p>假设说我们现在需要实现一个功能，是在页面里有一个分享按钮，点击这个分享按钮后，打开app自己的分享功能。</p>
<p>第一步，我们需要实现这样一个Handler ，并且将其注册到Bridge中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bridge.registerHandler(<span class="string">"share_handler"</span>, <span class="keyword">new</span> WVJBHandler() &#123;   </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span> </span>&#123; </div><div class="line">        Log.d(<span class="string">"share info from js : "</span>, data); </div><div class="line">        callback.callback(<span class="string">"share success"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二步，在js中，我们通过一个<code>callHandler</code>方法来请求java代码的执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">'function'</span>) &#123; </div><div class="line">        responseCallback = data; </div><div class="line">        data = <span class="literal">null</span>; </div><div class="line">    &#125; </div><div class="line">    _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (responseCallback) &#123; </div><div class="line">        <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span>+(uniqueId++)+<span class="string">'_'</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </div><div class="line">        responseCallbacks[callbackId] = responseCallback; </div><div class="line">        message[<span class="string">'callbackId'</span>] = callbackId; </div><div class="line">    &#125; </div><div class="line">    sendMessageQueue.push(message); </div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们在这里构造了一个Message对象，这个对象包含三个属性，一个是需要java处理的Handler名称，一个是data数据本身，还有是一个回调方法的id，这个回调方法就是java在执行完毕后的回调方法。此外，我们提供了一个Queue来保存这些请求的Message对象，之后通知java有Message进入到队列里面。<br>第三步，<code>WebViewClient</code>对这个请求进行拦截，并到javascript的queue中去取Message：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean shouldOverrideUrlLoading(WebView view, <span class="built_in">String</span> url) &#123; </div><div class="line">    ... </div><div class="line">    if (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        if (base.isQueueMessageUrl(url)) &#123; </div><div class="line">            <span class="built_in">String</span> javascriptCommand = base.javascriptFetchQueryCommand(); </div><div class="line">            bridge.evaluateJavascript(javascriptCommand); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        return <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在Android中执行javascript后不会反回结果，所以为了拿到Message对象，我们需要将这个Message对象像参数一样附在请求的后面传递给java：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_fetchQueue</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(sendMessageQueue); </div><div class="line">    sendMessageQueue = []; </div><div class="line">    <span class="comment">// android 不能直接返回结果,做在放在url中返回 </span></div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + RETURN_WITH_MESSAGE + <span class="string">'/'</span> + messageQueueString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，这个请求会再次被<code>WebViewClient</code>拦截，并解析<code>Message</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        <span class="keyword">if</span> (base.isReturnMessageUrl(url)) &#123; </div><div class="line">            String messageQueueString = base.messageQueueStringFromReturnUrl(url); </div><div class="line">            base.flushMessageQueue(messageQueueString); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>flushMessageQueue</code>方法中，主要执行的就是解析Message，并调用对应的Handler来进行处理，在处理完毕后，回调javascript的callback方法返回结果。到此，java与javascript的一个完整的交互流程就完成了。更完整的代码可以参考：<a href="https://github.com/xiaoza/WebViewJavascriptBridgeForAndroid" target="_blank" rel="external">WebViewJavascriptBridgeForAndroid</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在开发Android应用的时候，很多的时候需要跟网页打交道，假如我们现在在做一个外卖app，在app首页会有一个轮询的广告位，我们点击其
    
    </summary>
    
    
      <category term="android" scheme="http://iszhenyu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Picasso源码解析</title>
    <link href="http://iszhenyu.me/posts/2016-06-29-Picasso%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://iszhenyu.me/posts/2016-06-29-Picasso源码解析.html</id>
    <published>2016-06-29T03:22:07.000Z</published>
    <updated>2016-09-07T06:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Picasso作为一个非常棒的android第三方图片加载库，在Github上获得了高达7000多的star。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context).load(“image url”).into(imageView);</div></pre></td></tr></table></figure>
<p>这么简单的一行代码就完成了在Android中加载图片的功能，这其中，Picasso还帮我们自动完成了一些android中处理图片的问题：例如在adapter中ImageView的回收和取消下载，使用最小的内存来完成图片的过渡，自动的内存和磁盘缓存等，的确是非常简单的。</p>
<p>但作为开发人员，简单的会用是不够的，毕竟我们在实际项目中可能会遇到各种奇葩问题，这个时候就有必要深入到内部一探究竟了。下面就从源码的角度来讲解一下Picasso的工作原理。我们可以直接在github上 clone下整个Picasso项目或者如果你使用的是studio的gradle依赖管理，那么也可以直接在项目的Extension Library中查看Picasso的源码。</p>
<p>我们先看下上面一行代码中用到的三个函数，首先是with函数，它的实现是这个样子的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Content context)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">synchronized</span> (Picasso.class) &#123;</div><div class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Builder().build();</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> singleton;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">可以看到Picasso使用的是单例模式，并且使用Builder模式创建了一个Picasso的实例，具体如何创建的我们这里先不管，继续往下看。</div><div class="line">有了这个的实例之后，直接调用了它的load函数，Picasso重载了几个不同参数的load函数，用以从不同的地点来加载图片：</div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(Uri uri)</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(<span class="keyword">int</span> resourceId)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过load函数，我们最终得到了一个RequestCreator对象，通过这个对象我们就可以定制一些对图片的特殊处理了，这里我们同样不去深究这个RequestCreator内部是如果对图片进行处理的。<br>最后我们调用了into函数，将加载到的图片赋给一个ImageView控件。我们前面的操作可以说都是为into函数做准备，实际工作的开始，就是在into里面完成的。我们跟进<code>into</code>方法看一下，当然了，我们现在还是主要关注流程，不必过于深究细节，这个方法稍微有点长，但是为了方便起见，我们把它的代码贴在这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(Target target)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> started = System.nanoTime();</div><div class="line">    checkMain();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (deferred) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with a Target."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            picasso.cancelRequest(target);</div><div class="line">            target.onBitmapLoaded(bitmap, MEMORY);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable,</div><div class="line">            requestKey, tag, errorResId);</div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法稍微有些长，但是逻辑还是比较清晰的，我们总结一下：</p>
<ol>
<li>into会检查当前是否是在主线程上执行。</li>
<li>如果我们没有提供一个图片资源并且有设置placeholder，那么就会把我们设置的placeholder显示出来，并中断执行。</li>
<li>defered属性我们一般情况下不需要关注，只有当我们调用了RequestCreator的fit方法时defered才为true，但我们几乎不会这样做。</li>
<li>接下来就是创建了一个Request对象，我们在前面做得一些设置都会被封装到这个Request对象里面。</li>
<li>检查我们要显示的图片是否可以直接在缓存中获取，如果有就直接显示出来好了。</li>
<li>缓存没命中，那就只能费点事把源图片down下来了。这个过程是异步的，并且通过一个Action来完成请求前后的衔接工作。</li>
</ol>
<p>至此，Picasso在主线程中的工作就结束了。通过上面的分析，我们看到Picasso的思想还是很清晰的：首先通过Picasso创建了一个RequestCreator对象，通过这个对象我们可以针对不同的场景来设置一些属性，之后创建出Request对象，最后通过Action来确定异步请求并对请求结果做处理。</p>
<p>接下来，我们就深入到内部看下具体的执行。首先看下Picasso构造函数的声明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</div><div class="line">      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,</div><div class="line">      Bitmap.Config defaultBitmapConfig, <span class="keyword">boolean</span> indicatorsEnabled, <span class="keyword">boolean</span> loggingEnabled) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么多的参数，也基本上涵盖了Picasso内部所有重要的组件。同时我们也看到这个Picasso是不允许外部进行实例化的。在这里，Picasso使用了单例和建造者模式来完成Picasso的实例化，在Builder中实例化了Picasso所需要的这些组件，这里使用Builder模式的另一个好处就是可以让我们根据自己的需求来个性化定制组件。那这些组件到底都是做什么的呢，下面我们就一一探个究竟。</p>
<p>既然Picasso是通过Builder来实例化的，那我们就从build函数入手，看一下都做了哪些工作。同样，为了阅读方便，我们把build的代码贴在下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">        downloader = Utils.createDefaultDownloader(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line">        cache = <span class="keyword">new</span> LruCache(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</div><div class="line">        transformer = RequestTransformer.IDENTITY;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(cache);</div><div class="line"></div><div class="line">      Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>build结束后，就为Picasso创建了如下几个对象：<br>Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher，从名称上我们基本上已经能够猜测出来每个组件都是干嘛的。这些对象传递给Picasso的构造函数后，在构造函数的内部又创建了了不同的RequestHandler，用以对不用的图片资源进行加载。说了这么多是不是有点晕，别急，下面我们会对每个组件做介绍，一点点将Picasso的执行过程串起来。</p>
<p>我们先来看下Downloader：它是一个接口，规定了一些通用的方法，这也就意味着，我们可以提供自己的下载器，只要实现这个接口即可，Picasso的扩展能力还是很不错的。这里Picasso默认使用OkHttpClient来作为下载器，同样也是squareup公司开源的一个网络库。</p>
<p>Cache：Picasso的缓存，这里实例化的是LruCache，其内部使用的是LinkedHashMap</p>
<p>ExecutorService：这里Picasso实现了自己的PicassoExecutorService，它继承了ThreadPoolExecutor，也就是Picasso自己维护了一个线程池，用于异步加载图片。</p>
<p>RequestTransformer：主要是对RequestCreator创建的Request进行转换，默认对Request对象不做处理。</p>
<p>Stats：这个类只要是维护图片的一些状态</p>
<p>Dispatcher：从名字上就可以判断出来，这个类在这里起到了一个调度器的作用，图片要不要开始下载以及下载后Bitmap的返回都是通过这个调度器来执行的，后面我们会对它进行更加详细的讲解。</p>
<p>对Picasso几个核心类有了大致了解后，我们再来看它到底是如何执行一个异步请求，又是如何将执行结果返回的。<br>通过上面的分析我们知道，RequestCreator在into方法的最后会创建一个Action实例，然后调用Picasso的enqueueAndSubmit方法，而最终是调用了Dispatcher的dispatchSubmit方法，也就是我们前面说的，Dispatcher起到了调度器的作用。在Dispatcher内部，Dispatcher定义了DispatcherThread和DispatcherHandler两个内部类，并在Dispatcher的构造函数中对他们经行了实例化，所有的调度也都是通过handler异步的执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler,</div><div class="line">      Downloader downloader, Cache cache, Stats stats) &#123;</div><div class="line">    <span class="keyword">this</span>.dispatcherThread = <span class="keyword">new</span> DispatcherThread();</div><div class="line">    <span class="keyword">this</span>.dispatcherThread.start();</div><div class="line">    ...</div><div class="line">    <span class="keyword">this</span>.handler = <span class="keyword">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class="keyword">this</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，我们看到的dispatchSubmit方法就如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在handler中最终调用了performSubmit方法来触发一个图片的加载，那么我们来看一下这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class="line">        pausedActions.put(action.getTarget(), action);</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</div><div class="line">        hunter.attach(action);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</div><div class="line">    hunter.future = service.submit(hunter);</div><div class="line">    hunterMap.put(action.getKey(), hunter);</div><div class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</div><div class="line">        failedActions.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法并不发杂，主要是获得BitmapHunter实例，由这个实例来执行实际的下载操作。BitmapHunter本身是Runnable的一个实现，而这个实例最终是交由Picasso线程池进行运行的。</p>
<p>那么这个BitmapHunter加载图片完成或失败后是怎么通知UI的呢？我们前面提到Dispatcher在Picasso中起到了一个调度器的作用，当图片加载完毕后自然也是通过这个调度器来更新UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        updateThreadName(data);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">            log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = hunt();</div><div class="line">        <span class="comment">// 通过Dispatcher来处理结果</span></div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>() &#123; </div><div class="line">        <span class="comment">//各种异常处理</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>假如我们的图片成功下载下来了，接下来就看看这个图片是如何被渲染到ImageView中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过handler来发送一个message，我们再看消息处理函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_COMPLETE: &#123;</div><div class="line">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class="line">          dispatcher.performComplete(hunter);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们最终执行了performComplete方法。在这个方法了会自动处理图片的缓存问题，方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</div><div class="line">      cache.set(hunter.getKey(), hunter.getResult());</div><div class="line">    &#125;</div><div class="line">    hunterMap.remove(hunter.getKey());</div><div class="line">    batch(hunter);</div><div class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，Picasso并不是立即将图片显示出来，而是用到了一个批处理，其实就是把操作先暂存在一个list中，等空闲的时候再拿出来处理，这样做得好处也是尽量减少主线程的执行时间，一方面防止ANR，另一方面快速返回，响应页面的其他渲染操作，防止卡顿用户界面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handMessage中对应的处理方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</div><div class="line">          dispatcher.performBatchComplete();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，通过这个batch我们实际看到，最后还是调用了Dispatcher的方法来处理，但由于这个处理并非是在主线程（参考前面Dispatcher构造函数中Handler的实例化），因此我们还需要通过一个主线程的Handler来处理这个请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class="line">    batch.clear();</div><div class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class="line">    logBatch(copy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个mainThreadHandler是在Dispatcher实例化时由外部传递进来的，我们在前面的分析中看到，Picasso在通过Builder创建时会对Dispatcher进行实例化，在那个地方将主线程的handler传了进来，我们回到Picasso这个类，看到其有一个静态成员变量HANDLER，这样我们也就清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class="line">          <span class="comment">//noinspection ForLoopReplaceableByForEach</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class="line">            BitmapHunter hunter = batch.get(i);</div><div class="line">            hunter.picasso.complete(hunter);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>到这里，我们的图片马上就要显示出来了。我们前面提到，Picasso中一个Action提供了请求前后的衔接工作，对于我们现在的情况，Picasso使用了ImageViewAction来进行处理，也就是在ImageViewAction中的complete方法完成了最后的图片渲染工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</div><div class="line">          String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Context context = picasso.context;</div><div class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">      callback.onSuccess();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，到此，一个图片从开始下载到成功渲染到ImageView中整个流程就讲完了。其中，Dispatcher那块的调度有点绕，如果不是很理解，可以先熟悉下android中handler的用法，handler本身也是android提供给我们方便进行线程间通信的，就像Picasso的实现一样，善用handler可以帮助我们实现更加流畅的用户UI操作体验。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Picasso作为一个非常棒的android第三方图片加载库，在Github上获得了高达7000多的star。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
    
    </summary>
    
    
      <category term="android" scheme="http://iszhenyu.me/tags/android/"/>
    
  </entry>
  
</feed>
