<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhenyu</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://iszhenyu.me/"/>
  <updated>2017-03-26T13:02:26.000Z</updated>
  <id>http://iszhenyu.me/</id>
  
  <author>
    <name>zhenyu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于Flask，构建自己的Web框架</title>
    <link href="http://iszhenyu.me/posts/2017-03-26-%E5%9F%BA%E4%BA%8EFlask%EF%BC%8C%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Web%E6%A1%86%E6%9E%B6.html"/>
    <id>http://iszhenyu.me/posts/2017-03-26-基于Flask，构建自己的Web框架.html</id>
    <published>2017-03-26T13:00:31.000Z</published>
    <updated>2017-03-26T13:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>Flask是一个使用Python编写的轻量级Web应用框架，因为它强大的自由性，从推出开始就受到大家的热捧，在官方文档和其他介绍Flask的文章中，你一定没少看到下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from flask import Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line">@app.route(&quot;/&quot;)</div><div class="line">def hello():</div><div class="line">    return &quot;Hello World!&quot;</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    app.run()</div></pre></td></tr></table></figure></p>
<p>简单的几行就获得了一个可运行的web应用，这让新手入门变得非常简单。但是，随着系统复杂度的上升，单个文件已经无法满足需求，于是出现了所谓的大型应用架构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">|-flasky</div><div class="line">  |-app/</div><div class="line">    |-templates/</div><div class="line">    |-static/</div><div class="line">    |-main/</div><div class="line">      |-__init__.py</div><div class="line">      |-errors.py</div><div class="line">      |-forms.py</div><div class="line">      |-views.py</div><div class="line">    |-__init__.py</div><div class="line">    |-email.py</div><div class="line">    |-models.py</div><div class="line">  |-migrations/</div><div class="line">  |-tests/</div><div class="line">    |-__init__.py</div><div class="line">    |-test*.py</div><div class="line">  |-venv/</div><div class="line">  |-requirements.txt</div></pre></td></tr></table></figure>
<p>对于不是特别复杂的系统，可以采用如上的模式开发，但实际情况是，我们通常所面对的业务要复杂的多，这样就无法把所有模型都放在同一个<code>models.py</code>文件中，同理，<code>views.py</code>、<code>forms.py</code>也是如此。除了代码结构，还有其他的一些因素需要考虑，例如：如何记录日志，如何处理错误信息等等，只要我们使用Flask，就不得不一遍遍的去做这样的事情。对于一个框架来说，开发人员应该不用去关注框架本身，而是将精力全部集中到业务实现。因此，我决定基于Flask来封装自己的web框架（<a href="https://github.com/iszhenyu/fiji" target="_blank" rel="external">Github</a>），而这个框架在很大程度上参考了<a href="http://mattupstate.com/blog/how-i-structure-my-flask-applications/" target="_blank" rel="external">How I Structure My Flask Applications</a> 这篇博客。</p>
<p>封装后的Web框架的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── README.md</div><div class="line">├── app</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── controllers</div><div class="line">│   ├── forms</div><div class="line">│   ├── models</div><div class="line">│   ├── services</div><div class="line">│   ├── core.py</div><div class="line">│   ├── exceptions.py</div><div class="line">│   ├── extensions.py</div><div class="line">│   └── factory.py</div><div class="line">├── config</div><div class="line">│   ├── __init__.py</div><div class="line">│   ├── settings.dev.py</div><div class="line">│   ├── settings.pro.py</div><div class="line">│   └── settings.py</div><div class="line">├── logs</div><div class="line">│   └── dev.log</div><div class="line">├── manage.py</div><div class="line">├── public</div><div class="line">├── requirements</div><div class="line">│   ├── dev.txt</div><div class="line">│   └── pro.txt</div><div class="line">├── utils</div><div class="line">└── venv</div></pre></td></tr></table></figure></p>
<p>之所以这样安排目录结构，是考虑到有些同学可能是从PHP或Java转移过来的，他们还是比较熟悉按层来划分模块，而不是根据功能来划分。在使用的时候，只需要在对应的模块中添加业务代码，真正做到了开箱即用。更详细的信息大家看代码吧，地址如下：<br><a href="https://github.com/iszhenyu/fiji" target="_blank" rel="external">https://github.com/iszhenyu/fiji</a><br>也欢迎大家一起交流。</p>
<hr>
<p>微信号<code>在课间</code>，每天5分钟，分享程序员成长中的点滴，聚沙成塔，聚水成涓，一起提升自己。</p>
<p><img src="http://oliobk3g2.bkt.clouddn.com/qrcode_for_gh_c2450942f355_258.jpg" alt="在课间" title="title"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flask是一个使用Python编写的轻量级Web应用框架，因为它强大的自由性，从推出开始就受到大家的热捧，在官方文档和其他介绍Flask的文章中，你一定没少看到下面的代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
    
      <category term="Flask" scheme="http://iszhenyu.me/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>当我们在使用Flask时，如何如记录日志</title>
    <link href="http://iszhenyu.me/posts/2017-01-25-%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8%E4%BD%BF%E7%94%A8Flask%E6%97%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A6%82%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97.html"/>
    <id>http://iszhenyu.me/posts/2017-01-25-当我们在使用Flask时，如何如记录日志.html</id>
    <published>2017-01-25T02:29:29.000Z</published>
    <updated>2017-01-25T02:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发基于Flask的Web应用时，往往容易忽略了对日志的使用，而在Flask的官方文档中，对日志这块的介绍也仅仅停留在如何与系统集成上。记录日志这个看似很简单的事情，在实际中很多人却不一定能做好，要么不知道何时进行日志记录，要么就是记录的日志然并卵。所以，今天就来说说记录日志这件小事。</p>
<p>说它是件小事，因为它的确不会影响你系统的正常流程，有没有它系统都能跑起来，也正因为这样，很多人便忽略了日志的处理，或者干脆都没有配置日志输出，整个系统没有任何日志输出（Nginx日志不算）。当然，如果是我们自己开发的一些小网站，大家用来练练手或着用户量不大，有没有日志都一样，但是对于一些大型的系统，它的用户是很多的，在任何一个环节都可能出问题，为了能够及时的定位问题和监控系统运行状态，正确合理的记录日志就非常非常重要了。一般情况下，我们需要关注的是三个方面的内容：</p>
<ul>
<li>日志信息的集中采集、存储和检索：这个主要是在多节点的情况下如何方便的查看日志信息。</li>
<li>日志信息的输出策略：要保证日志输出的全面而又不显凌乱，方便开发人员跟踪和分析问题。</li>
<li>关键业务的日志输出：我们常说的<code>打点</code>就属于这个范畴，比如我们的一些浏览记录等，这个就需要根据业务要求来做针对性设计了。</li>
</ul>
<p>我们在这里主要是围绕第二个问题来展开，也是我们开发人员最直接接触的情况。</p>
<h2 id="日志输出级别"><a href="#日志输出级别" class="headerlink" title="日志输出级别"></a>日志输出级别</h2><p>从Flask 0.3 版本开始，系统就已经帮我们预配置了一个logger，而这个logger的使用也是非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.logger.debug(&apos;A value for debugging&apos;)</div><div class="line">app.logger.warning(&apos;A warning occurred (%d apples)&apos;, 42)</div><div class="line">app.logger.error(&apos;An error occurred&apos;)</div></pre></td></tr></table></figure>
<p>其中的app就是Flask的实例，而这个app.logger也就是一个标准的logging Logger，因此，我们在使用app.logger时可选择的输出级别与python logging中的定义是一致的。</p>
<ul>
<li><code>ERROR</code>：这个级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用了，系统的关键业务流程走不下去了等等。很多人在实际开发的时候，不会去区分问题的重要程度，只要有问题就error记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内error日志的数量来确定的。因此如果我们不分轻重缓急，一律error对待，就会徒增报错的频率，久而久之，我们的救火队员对错误警报就不会那么在意，这个警报也就失去了原始的意义。</li>
<li><code>WARN</code>：发生这个级别的问题时，处理过程可以继续，但必须要对这个问题给予额外的关注。假设我们现在有一个系统，希望用户每一个月更换一次密码，而到期后，如果用户没有更新密码我们还要让用户可以继续登录，这种情况下，我们在记录日志时就需要使用WARN级别了，也就是允许这种情况存在，但必须及时做跟踪检查。</li>
<li><code>INFO</code>：这个级别的日志我们用的也是比较多，它一般的使用场景是重要的业务处理已经结束，我们通过这些INFO级别的日志信息，可以很快的了解应用正在做什么。我们以在12306上买火车票为例，对每一张票对应一个INFO信息描述“[who] booked ticket from [where] to [where]”。</li>
<li><code>DEBUG</code>和<code>TRACE</code>：我们把这两个级别放在一起说，是应为这两个级别的日志是只限于开发人员使用的，用来在开发过程中进行调试，但是其实我们有时候很难将DEBUG和TRACE区分开来，一般情况下，我们使用DEBUG足以。</li>
</ul>
<p>以上就是我们实际开发中最多接触的几种日志级别，基本能覆盖99%的情况。最后我们要注意的就是，最好能尽可能输出更多的日志信息，并且不做任何过滤，同时输出的每一条日志的详细信息要切当，让我们可以快速过滤并找到所需的信息。</p>
<h2 id="日志输出信息"><a href="#日志输出信息" class="headerlink" title="日志输出信息"></a>日志输出信息</h2><p>当我们确定了使用哪个级别来写入日志后，下一步要做的就是确定要记录什么样的信息。针对这一块的内容，其实又可以细分。</p>
<h3 id="日志应该记录什么"><a href="#日志应该记录什么" class="headerlink" title="日志应该记录什么"></a>日志应该记录什么</h3><p>一般来说，日志的记录要满足几个要求：可读、干净、详细和自描述。我们先来看几个反模式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.logger.debug(&apos;message processed&apos;)</div><div class="line">app.logger.debug(message.get_message_id())</div><div class="line">app.logger.debug(&apos;message with id %s&apos;, message.get_message_id())</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if isinstance(message, TextMessage):</div><div class="line">    ...</div><div class="line">else:</div><div class="line">    app.logger.warn(&apos;unknow message type&apos;)</div></pre></td></tr></table></figure>
<p>上面列出的这几个例子，问题在什么地方呢？当看到这些日志信息后，我们首先意识到的肯定是哪里出了问题，但是，这个问题产生的原因是什么我们并不清楚，也就是说，只根据这样的日志我们是没办法对问题进行修复的。所以我们在记录日志的时候，应该要尽量的详细，日志的上下文要交代清楚。</p>
<p>另外一种反模式的日志信息，我们通常叫做魔法日志。就比如说，有的开发人员为了自己查找信息方便，会输出一些类似<code>&amp;&amp;&amp;###&gt;&gt;&gt;&gt;&gt;&gt;</code>的日志，这些特殊的符号只有开发者本人清楚到底是做什么的，而对其他人来说，看到这些日志绝对是一脸懵逼。即使是开发者本人，哪怕当时能够清楚这些魔法日志的特殊含义，但时间一长，估计他们也很难回想起当时为啥要输出这些鬼东西了吧。</p>
<p>其次，还有一种是要关注外部系统，也就是在和任何外部系统通信的时候，建议记录所有进出系统的数据。但是，记录这些信息时，性能是一个比较头痛的问题，有时，需要和外部系统交换的信息量太大，导致无法记录所有信息。但是，在调试或测试期间我们还是愿意记录所有信息，并准备为此付出一些性能的代价，这个可以通过仔细控制log级别来实现，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if app.config[&apos;debug&apos;]:</div><div class="line">    app.logger.debug(&apos;...&apos;)</div><div class="line">else:</div><div class="line">    app.logger.info(&apos;...&apos;)</div></pre></td></tr></table></figure>
<p>最后要提的一点就是，我们输出的这些日志信息中，绝对不可以透露系统密码和一些个人信息。</p>
<h3 id="如何打印日志内容"><a href="#如何打印日志内容" class="headerlink" title="如何打印日志内容"></a>如何打印日志内容</h3><p>当我们明确了该用哪个级别去记录哪些信息后，就要把这些信息输出到日志文件中，但是想正确高效的打印日志内容也并非一件简单的事。Flask已经帮我们预配置了一个logger，我们可以使用这个logger来完成我们所有的打印操作。</p>
<blockquote>
<p>我们在记录日志的时候绝对不可以使用<code>print</code>，即使我们在开发调试的时候能够在控制台看到打印的信息，但是这样的信息并不会记录到日志文件中，当我们的程序上线后，跟没有记录日志的效果是一样的。因此，哪怕是在开发调试时，也要尽量使用logger。</p>
</blockquote>
<p>最简单的日志打印就是输出一个字符串，比如像下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.logger.info(&apos;this is a string&apos;)</div></pre></td></tr></table></figure>
<p>但大部分时候，我们要记录的信息都会包含一些参数，有一种实现方式是提前构造出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message_info = &apos;the message is %s&apos; % info</div><div class="line">app.logger.info(message_info)</div></pre></td></tr></table></figure>
<p>这种写法也没啥问题，但其实，logger内部也可以帮助我们完成上面的操作，也就是我们还可以写成下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.logger.info(&apos;the message if %s&apos;, info)</div></pre></td></tr></table></figure>
<p>这样看起来是不是简洁了好多呢？</p>
<h2 id="记录异常信息"><a href="#记录异常信息" class="headerlink" title="记录异常信息"></a>记录异常信息</h2><p>记录异常信息严格来说也应该算到日志输出的范畴，之所以把它拿出来单独说，是因为除了说明应该怎样去记录异常外，这里还要说下如何去自定义异常。</p>
<h3 id="正确的记录异常信息"><a href="#正确的记录异常信息" class="headerlink" title="正确的记录异常信息"></a>正确的记录异常信息</h3><p>对于异常，我们更想看到的其实是它的堆栈信息，而不是简单的一句话，堆栈信息可以帮助我们快速的定位问题出处。如果想打印堆栈，我们前面的记录方法就不再实用了，哪怕我们把<code>Exception</code>的实例丢到logger里打印出来的也仅仅是错误信息而不是堆栈信息。比如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3]</div><div class="line">try:</div><div class="line">    print a[3]</div><div class="line">except Exception, e:</div><div class="line">    logging.error(e)</div></pre></td></tr></table></figure>
<p>如果我们查看日志，发现打印出的仅仅是一行错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tue, 24 Jan 2017 16:07:20 demo.py[line:22] ERROR list index out of range</div></pre></td></tr></table></figure>
<p>那如何打印出堆栈信息呢？python给我们提供了一个<code>exception</code>方法，它的使用跟<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>几个方法是一样的，我们可以把上面的代码修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3]</div><div class="line">try:</div><div class="line">    print a[3]</div><div class="line">except Exception, e:</div><div class="line">    logging.exception(e)</div></pre></td></tr></table></figure>
<p>之后我们再看日志输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Tue, 24 Jan 2017 17:19:37 demo.py[line:22] ERROR list index out of range</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Users/xiaoz/developments/python/ttest/demo.py&quot;, line 20, in test</div><div class="line">    print a[3]</div><div class="line">IndexError: list index out of range</div></pre></td></tr></table></figure>
<p>除了我们上面使用<code>error</code>方法打印的错误信息外，还打印出了出错的堆栈信息，由此看见，<code>exception</code>方法打印的日志会包含两项，第一项就是调用<code>exception</code>方法时传入的message，还有一项是紧跟在message后面的堆栈信息。</p>
<blockquote>
<p>当我们使用<code>exception</code>方法时，它记录的日志级别为<code>ERROR</code>，如果我们希望打印出堆栈信息，同时又不希望使用<code>ERROR</code>这个级别怎么办呢？如果你查看<code>exception</code>方法的实现，会发现，它只是多加了一行代码<code>kwargs[&#39;exc_info&#39;] = 1</code>，然后调用了<code>error</code>方法，以此类推，如果我们希望打印堆栈信息就可以像下面这样写：<code>app.logger.info(&#39;message info is %s&#39;, message, exc_info=1)</code>。</p>
</blockquote>
<p>Flask允许我们自定义对异常的处理，一般情况下，我们会做一些统一处理，比如下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@app.errorhandler(500)</div><div class="line">def internal_server_error(e):</div><div class="line">    app.logger.exception(&apos;error 500: %s&apos;, e)</div><div class="line">    response = json_error(&apos;internal server error&apos;)</div><div class="line">    response.status_code = 500</div><div class="line">    return response</div></pre></td></tr></table></figure>
<p>我们在返回结果的同时，对错误信息进行了记录处理，这样做也是为了避免模板代码，减少开发人员的工作量。但是，在减少我们开发量的同时，这也意味着可能会带来另外一个问题，很多程序员喜欢捕获异常后将错误写入日志，然后再将异常包装后重新抛出，这样会重复打印日志信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">... some thing ...</div><div class="line">try:</div><div class="line">    ... do some thing ...</div><div class="line">except Exception, e:</div><div class="line">    app.logger.error(e)</div><div class="line">    raise SomeException(e)</div></pre></td></tr></table></figure>
<p>还有一种情况，如果我们在捕获异常的时候，不分情况统一捕获<code>Exception</code>也是不对的。直接捕获<code>Exception</code>固然方便，但是我们捕获的范围太大的话，有的时候会吃掉关键的信息，而这些被吃掉的异常又没有打印错误信息和堆栈，一旦有问题，是很难排查的，比如我们定义了下面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def some_method():</div><div class="line">    .. do some thing ..</div><div class="line">    try:</div><div class="line">        .. do dome thing 2 ..</div><div class="line">        return True</div><div class="line">    except Exception, e:</div><div class="line">        return False</div></pre></td></tr></table></figure>
<p>当<code>do some thing 2</code>中发生异常时，我们是没法察觉到的，这样不但会使方法返回不正确，也会给排查带来困难。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>首先，我们看看为什么要自定义异常，在需要抛出异常的地方，我们直接<code>raise Exception()</code>不好吗？答案很显然，肯定是不好，具体的原因，我们下面就逐条分析下。</p>
<ol>
<li>大多时候我们都是使用json来为不同端提供接口支持，不管成功与否，都必须使用统一的数据格式。如果系统充斥着各种异常就很难做到统一。</li>
<li>要能反映出该异常的重要程度，比如：如果是参数校验异常则被认为不是很重要，可能直接记下warn日志就行了，而orm异常必须要记录error日志。</li>
<li>最后，对于异常的信息要有区分，比如，对于orm异常，我们希望给用户看到的是一条简单的系统出错的提示信息，而我们在查看日志时必须要有详细的异常信息。</li>
</ol>
<p>为了解决上面的问题，需要我们来自定义异常，并且使用的时候也尽量要使用已定义的异常类。这里我们来看一种实现方式，大家可以参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">class BaseError(Exception):</div><div class="line"></div><div class="line">    default_status_code = 200</div><div class="line"></div><div class="line">    LEVEL_DEBUG = 0</div><div class="line">    LEVEL_INFO = 1</div><div class="line">    LEVEL_WARN = 2</div><div class="line">    LEVEL_ERROR = 3</div><div class="line"></div><div class="line">    def __init__(self, message, status_code=None, extras=None, parent_error=None):</div><div class="line">        self._message = message</div><div class="line">        self._code = status_code</div><div class="line">        self.extras = extras</div><div class="line">        self.parent_error = parent_error</div><div class="line">        self.level = BaseError.LEVEL_DEBUG</div><div class="line"></div><div class="line">    @property</div><div class="line">    def status_code(self):</div><div class="line">        if not self._code:</div><div class="line">            return BaseError.default_status_code</div><div class="line">        return self._code</div><div class="line"></div><div class="line">    def to_dict(self):</div><div class="line">        rv = &#123;</div><div class="line">            &apos;error_message&apos;: self._message,</div><div class="line">            &apos;status_code&apos;: self.status_code,</div><div class="line">            &apos;success&apos;: False</div><div class="line">        &#125;</div><div class="line">        return rv</div><div class="line"></div><div class="line"></div><div class="line">class ValidationError(BaseError):</div><div class="line">    def __init__(self, message, extras=None):</div><div class="line">        super(ValidationError, self).__init__(message=message, extras=extras)</div><div class="line">        self.level = BaseError.LEVEL_INFO</div><div class="line"></div><div class="line"></div><div class="line">class NotFoundError(BaseError):</div><div class="line">    def __init__(self, message, extras=None):</div><div class="line">        super(NotFoundError, self).__init__(message=message, extras=extras)</div><div class="line">        self.level = BaseError.LEVEL_WARN</div><div class="line"></div><div class="line"></div><div class="line">class FormError(BaseError):</div><div class="line">    def __init__(self, form):</div><div class="line">        message = form.get_validate_error()</div><div class="line">        super(FormError, self).__init__(message, extras=form.data)</div><div class="line">        self.level = BaseError.LEVEL_INFO</div><div class="line"></div><div class="line"></div><div class="line">class OrmError(BaseError):</div><div class="line">    def __init__(self, message, status_code=None, extras=None, parent_error=None):</div><div class="line">        super(OrmError, self).__init__(message, status_code, extras, parent_error)</div><div class="line">        self.level = BaseError.LEVEL_ERROR</div></pre></td></tr></table></figure>
<p>定义了上面的异常信息后，我们在统一处理错误信息的时候就可以像下面这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@app.errorhandler(BaseError)</div><div class="line">def custom_error_handler(e):</div><div class="line">    if e.level in [BaseError.LEVEL_WARN, BaseError.LEVEL_ERROR]:</div><div class="line">        if isinstance(e, OrmError):</div><div class="line">            app.logger.exception(&apos;%s %s&apos; % (e.parent_error, e))</div><div class="line">        else:</div><div class="line">            app.logger.exception(&apos;错误信息: %s %s&apos; % (e.extras, e))</div><div class="line">    response = jsonify(e.to_dict())</div><div class="line">    response.status_code = e.status_code</div><div class="line">    return response</div></pre></td></tr></table></figure>
<p>如此，就兼顾了日志的错误级别和接口返回的数据格式。</p>
<h2 id="我们还应该注意什么"><a href="#我们还应该注意什么" class="headerlink" title="我们还应该注意什么"></a>我们还应该注意什么</h2><p>其实，对于日志的记录，我们前面七七八八也讲了个差不多，在开发的时候如果我们能够注意到上面提到的一些问题，已经能够算是比较合格的打日志了。当然，还有一些小的问题，在最后还是要说明一下。</p>
<p>第一个，就是需要我们关键一下性能问题，也就是避免因为日志拖慢应用系统。如果输出的日志信息太多，必然会增加磁盘的写入负担，通常情况下，每小时输出到磁盘的数据量达到几百M就已经是上限了。</p>
<p>第二个，就是不要由于log语句导致业务过程中断。我们的本意是通过日志来记录系统的一些运行信息，但是，log语句本身也是有可能发生异常的，如果因为我们的代码，导致日志记录的时候抛出了异常，就真的是得不偿失了。</p>
<p>OK，关于在Flask系统中如何进行日志记录，就介绍到这了，其实，上面提到的内容不仅在Flask系统中可行，基本上所有的Web系统都有参考价值。大家有什么问题，欢迎交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开发基于Flask的Web应用时，往往容易忽略了对日志的使用，而在Flask的官方文档中，对日志这块的介绍也仅仅停留在如何与系统集成上。记录日志这个看似很简单的事情，在实际中很多人却不一定能做好，要么不知道何时进行日志记录，要么就是记录的日志然并卵。所以，今天就来说说
    
    </summary>
    
    
      <category term="Flask" scheme="http://iszhenyu.me/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB索引的介绍及使用</title>
    <link href="http://iszhenyu.me/posts/2016-10-13-MongDB%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8.html"/>
    <id>http://iszhenyu.me/posts/2016-10-13-MongDB索引的介绍及使用.html</id>
    <published>2016-10-13T10:47:32.000Z</published>
    <updated>2016-10-13T10:46:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>索引的重要性，应该无需多说了，它可以优化我们的查询，而且在某些特定类型的查询中，索引几乎是必不可少的。这篇文章主要介绍了MongoDB中的几种常见的索引以及在使用时候的一些注意事项。这几种索引基本上涵盖了我们在平时开发的时候会遇到的大部分情况，但是，仍然需要注意的是，这篇文章没有涉及一些特殊的索引，比如TTL索引、全文本索引和地理空间索引，想要了解这几个索引的同学在这里可能得不到想要的答案。</p>
<h2 id="单一索引"><a href="#单一索引" class="headerlink" title="单一索引"></a>单一索引</h2><p>单一索引应该是MongoDB里最简单和最容易理解的索引，但由于MongoDB是一个非关系型数据库，它的索引结构跟常见的关系型数据库（例如MySQL）又有所不同。</p>
<h3 id="1、在单一字段上建立索引"><a href="#1、在单一字段上建立索引" class="headerlink" title="1、在单一字段上建立索引"></a>1、在单一字段上建立索引</h3><p>假设我们有一个名为records 的 collection ，其中存储的文档格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;),</div><div class="line">  &quot;score&quot;: 1034,</div><div class="line">  &quot;location&quot;: &#123; state: &quot;NY&quot;, city: &quot;New York&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们希望在<code>score</code>字段上建立<code>升序</code>索引，可以执行如下语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.records.createIndex(&#123;score:1&#125;)</div></pre></td></tr></table></figure>
<p>其中<code>1</code>代表索引按升序排列各项，<code>-1</code>代表按降序排列。这个索引支持在<code>score</code>字段进行查询，例如下面的查询语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.records.find(&#123;score: 2&#125;)</div><div class="line">db.records.find(&#123;score: &#123;$gt: 10&#125;&#125;)</div></pre></td></tr></table></figure>
<h3 id="2、在内嵌文档字段上建立索引"><a href="#2、在内嵌文档字段上建立索引" class="headerlink" title="2、在内嵌文档字段上建立索引"></a>2、在内嵌文档字段上建立索引</h3><p>同样，我们也可以在一个嵌入文档的字段上建立索引，注意这里是针对嵌入文档的某一个字段建立索引。还是考虑上面的文档，我们希望在location的state字段建立索引，可以如下操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.records.createIndex(&#123;&quot;location.state&quot;: 1&#125;)</div></pre></td></tr></table></figure>
<p>也就是，内嵌文档与字段之间用<code>.</code>分割就可以了。这个索引支持如下的查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.records.find(&#123;&quot;location.state&quot;: &quot;CA&quot;&#125;)</div><div class="line">db.records.find(&#123;&quot;location.city&quot;: &quot;Albany&quot;, &quot;location.state&quot;: &quot;NY&quot;&#125;)</div></pre></td></tr></table></figure>
<p>注意这里的第二个查询语句，<code>location.state</code>并不是第一位的查询条件，因为我们已经在<code>location.state</code>上加了索引，mongo会优先使用索引查询，所以这条语句也是有效的。</p>
<h3 id="3、在内嵌文档上建立索引"><a href="#3、在内嵌文档上建立索引" class="headerlink" title="3、在内嵌文档上建立索引"></a>3、在内嵌文档上建立索引</h3><p>在上面的例子中，<code>location</code>字段是一个内嵌文档，我们可以针对整个<code>location</code>字段来建立索引，这里需要注意与在内嵌文档字段上建立索引的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.records.createIndex(&#123;location: 1&#125;)</div></pre></td></tr></table></figure>
<p>考虑下面的查询语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.records.find(&#123;location: &#123;city: &quot;New York&quot;, state: &quot;NY&quot;&#125;&#125;)</div></pre></td></tr></table></figure>
<p>这条查询语句虽然可以使用这个刚刚建立的索引，但是却无法获取到正确的数据，因为在内嵌文档上执行精确匹配时，字段的顺序也必须跟内嵌文档中的字段顺序一致。</p>
<blockquote>
<p>我们上面构建索引的方式都是阻塞式的，也就是当我们在构建索引的时候，所有的数据都不可访问，直到索引构建完毕，这在正式环境中是绝对无法忍受的，解决这个问题也很简单，我们只要传递<code>background</code>参数就可以了，像下面这样<code>db.people.createIndex( { zipcode: 1}, {background: true} )</code>，这样mongo会在后台构建索引而不会阻塞其他的操作。</p>
</blockquote>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>简单来说，复合索引就是一个建立在多个字段上的索引。我们在正式开发的时候，很多查询条件都不是单一的，甚至有的时候排序方向都未必是单一的，这个时候复合索引就变得非常有用了。它的功能很强大，但同时，使用起来也很复杂。</p>
<h3 id="1、建立一个复合索引"><a href="#1、建立一个复合索引" class="headerlink" title="1、建立一个复合索引"></a>1、建立一个复合索引</h3><p>建立复合索引的语法是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.createIndex(&#123;&lt;field1&gt;: &lt;type&gt;, &lt;field2&gt;: &lt;type&gt;,...&#125;)</div></pre></td></tr></table></figure>
<p>其中，<code>&lt;type&gt;</code>指的就是那个字段索引的类型，比如为1说明是升序，-1说明是降序。</p>
<p>考虑一个名为<code>products</code>的collection，其中的文档如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> &quot;_id&quot;: ObjectId(...),</div><div class="line"> &quot;item&quot;: &quot;Banana&quot;,</div><div class="line"> &quot;category&quot;: [&quot;food&quot;, &quot;produce&quot;, &quot;grocery&quot;],</div><div class="line"> &quot;location&quot;: &quot;4th Street Store&quot;,</div><div class="line"> &quot;stock&quot;: 4,</div><div class="line"> &quot;type&quot;: &quot;cases&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以使用如下的语句在<code>item</code>和<code>stock</code>上建立了复合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.products.createIndex(&#123;&quot;item&quot;: 1, &quot;stock&quot;: 1&#125;)</div></pre></td></tr></table></figure>
<p>在这里，<code>item</code>和<code>stock</code>的顺序很重要，这个索引指向的文档首先会根据item字段来排序，而针对每个item字段值，会再根据stock字段来排序。</p>
<p>除了支持匹配所有索引字段的查询外，复合索引还支持匹配索引字段前缀的查询，例如，在建立上面的复合索引后，下面的查询语句也是被索引支持的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">db.products.find(&#123;item: &quot;Banana&quot;&#125;)</div><div class="line">db.products.find(&#123;item: &quot;Banana&quot;, stock: &#123;$gt : 5&#125;&#125;)</div></pre></td></tr></table></figure>
<h3 id="2、索引键的方向"><a href="#2、索引键的方向" class="headerlink" title="2、索引键的方向"></a>2、索引键的方向</h3><p>对于单一字段索引来说，按升序或降序排序是无关紧要的，因为MongoDB可以在相反的方向上来反转索引，然而对于复合索引，排序的次序问题就会对索引是否支持排序操作产生影响。</p>
<p>考虑一个名为<code>events</code>的集合，里面的每个文档都包括<code>username</code>和<code>date</code>字段，现在有一个查询，希望将结果按username升序，date降序排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.events.find().sort(&#123;username: 1, date: -1&#125;)</div></pre></td></tr></table></figure>
<p>或者是将username降序date升序排列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.events.find().sort(&#123;username: -1, date: 1&#125;)</div></pre></td></tr></table></figure>
<p>因为相互翻转（在每个方向上都乘以-1）的索引是等效的，所以，为了支持上面两种查询操作，可以建立如下的索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.events.createIndex(&#123;&quot;username&quot;: 1, &quot;date&quot;: -1&#125;)</div></pre></td></tr></table></figure>
<p>但是这个索引并不支持按username升序和date升序排列，也就是下面的查询是无法使用上面的索引的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.events.find().sort(&#123;username: 1, date: 1&#125;)</div></pre></td></tr></table></figure>
<p>那如果你真的是还有<code>{username: 1, date: 1}</code>这种排序需求，就只能再创建一个这个方向上的索引。</p>
<blockquote>
<p>只有基于多个查询条件进行排序时，索引的方向才是比较重要的，如果只是基于单一的键进行排序，MongoDB可以简单的从相反方向读取索引。</p>
</blockquote>
<h3 id="3、索引前缀"><a href="#3、索引前缀" class="headerlink" title="3、索引前缀"></a>3、索引前缀</h3><p>索引前缀就是索引字段的前几个字段，简单来说，如果有一个拥有N个键的索引，那么我们同时也得到了所有这N个键的前缀组成的索引。例如，有一个索引，它的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;item&quot;: 1, &quot;location&quot;: 1, &quot;stock&quot;: 1&#125;</div></pre></td></tr></table></figure>
<p>那么，也就意味着下面这两个索引也是可用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; item: 1 &#125;</div><div class="line">&#123; item: 1, location: 1 &#125;</div></pre></td></tr></table></figure>
<p>因此，如果我们的查询条件中包括以下几个字段，那么MongoDB就会使用到这个索引</p>
<ol>
<li>item 字段</li>
<li>item 和 location 字段</li>
<li>item 和 location 和 stock 字段</li>
</ol>
<p>而在下面的几个字段上是无法使用这个索引的</p>
<ol>
<li>location 字段</li>
<li>stock 字段</li>
<li>location 和 stock 字段</li>
</ol>
<p>最后我们考虑另外一种情况，假设我们现在有个如下所示的查询条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; item: xx, stock: xx &#125;</div></pre></td></tr></table></figure></p>
<p>那么这个查询会用到上面创建的索引吗？答案是肯定的，因为item字段可以看成是一个索引前缀，所以mongo首先会按item来查询，但是对于stock字段就无能为力了，因此，如果我们希望进一步加速上面的查询，则需要在<code>item</code>和<code>stock</code>两个字段上再建立索引。</p>
<h2 id="多键值索引"><a href="#多键值索引" class="headerlink" title="多键值索引"></a>多键值索引</h2><p>多键值索引又叫数组索引，它是为了能够高效搜索数组中特定元素而创建的索引。为了数组字段上建立索引，MongoDB会为数组中的每个元素建立索引条目，这也是为什么将数组索引称为多键值索引的原因。创建数组索引对数组中的元素类型没有太多要求，无论数组中元素是标量值（eg. strings、numbers）还是内嵌文档都是可以的。</p>
<p>可以使用如下的语法来创建数组索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.createIndex(&#123;&lt;field&gt;: &lt;1 or -1&gt;&#125;)</div></pre></td></tr></table></figure></p>
<p>我们发现，这与创建普通索引的语法是一样的，而不需要我们显示的指定为多键值索引，如果索引的字段是一个数组，MongoDB会自动创建为多键值索引。</p>
<p>我们在第二节提到了复合索引，并且在官方文档上也有明确标明：一个索引中的数组字段最多只能有一个。例如下面的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	_id: 1,</div><div class="line">	a: [1, 2],</div><div class="line">	b: [1, 2],</div><div class="line">	category: &quot;AB - both arrays&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们是无法创建<code>{a: 1, b: 1}</code>这样的复合多键索引的，因为a和b字段都为数组。那么我们不禁要问，问什么不可以呢？</p>
<p>我们知道，对于数组索引来说，数组中的每个元素都会被索引，假如字段a的元素个数为5，那么就要创建5条索引条目，而像上面的例子，a、b字段上每一对可能的元素都要被索引，也就是一共会有2 × 2个索引条目，当数组的长度很大时，索引的条目就会爆炸性增长，因此，为了避免这个问题，MongoDB规定只能最多有一个数组字段。</p>
<p>但是考虑另外一种情况，一个集合里面包含如下的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">	_id: 1, </div><div class="line">	a: [1, 2], </div><div class="line">	b: 1, </div><div class="line">	category: &quot;A array&quot; </div><div class="line">&#125;</div><div class="line">&#123; </div><div class="line">	_id: 2, </div><div class="line">	a: 1, </div><div class="line">	b: [1, 2], </div><div class="line">	category: &quot;B array&quot; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个复合多键索引<code>{a: 1, b: 1}</code>是允许的，因为对于每一个文档，只有一个字段为数组。当这个索引建立后，如果你尝试插入一条a和b都为数组的数据，将导致失败。</p>
<p>下面通过几个例子来更好的了解数组索引。</p>
<p><strong>索引基本数组</strong><br>考虑一个集合：survey，它存储了如下形式的文档：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	_id: 1,</div><div class="line">	item: &quot;ABC&quot;,</div><div class="line">	ratings: [2, 5, 9]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在ratings字段建立索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.survey.createIndex(&#123;ratings: 1&#125;)</div></pre></td></tr></table></figure>
<p>因为ratings字段包含数组，索引ratings上的索引为多键值索引，这个多键值索引包含如下三个索引键，每一个都指向了相同的文档：</p>
<ul>
<li>2</li>
<li>5</li>
<li>9</li>
</ul>
<p><strong>索引元素为嵌入文档的数组</strong></p>
<p>考虑下面的文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  _id: 1,</div><div class="line">  item: &quot;abc&quot;,</div><div class="line">  stock: [</div><div class="line">    &#123; size: &quot;S&quot;, color: &quot;red&quot;, quantity: 25 &#125;,</div><div class="line">    &#123; size: &quot;S&quot;, color: &quot;blue&quot;, quantity: 10 &#125;,</div><div class="line">    &#123; size: &quot;M&quot;, color: &quot;blue&quot;, quantity: 50 &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  _id: 2,</div><div class="line">  item: &quot;def&quot;,</div><div class="line">  stock: [</div><div class="line">    &#123; size: &quot;S&quot;, color: &quot;blue&quot;, quantity: 20 &#125;,</div><div class="line">    &#123; size: &quot;M&quot;, color: &quot;blue&quot;, quantity: 5 &#125;,</div><div class="line">    &#123; size: &quot;M&quot;, color: &quot;black&quot;, quantity: 10 &#125;,</div><div class="line">    &#123; size: &quot;L&quot;, color: &quot;red&quot;, quantity: 2 &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">  _id: 3,</div><div class="line">  item: &quot;ijk&quot;,</div><div class="line">  stock: [</div><div class="line">    &#123; size: &quot;M&quot;, color: &quot;blue&quot;, quantity: 15 &#125;,</div><div class="line">    &#123; size: &quot;L&quot;, color: &quot;blue&quot;, quantity: 100 &#125;,</div><div class="line">    &#123; size: &quot;L&quot;, color: &quot;red&quot;, quantity: 25 &#125;</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>下面的语句在 stock.size 和 stock.quantity 字段上建立了多键值索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.inventory.createIndex( &#123; &quot;stock.size&quot;: 1, &quot;stock.quantity&quot;: 1 &#125; )</div></pre></td></tr></table></figure>
<p>如下的查询语句都是OK的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.inventory.find( &#123; &quot;stock.size&quot;: &quot;M&quot; &#125; )</div><div class="line">db.inventory.find( &#123; &quot;stock.size&quot;: &quot;S&quot;, &quot;stock.quantity&quot;: &#123; $gt: 20 &#125; &#125; )</div><div class="line">db.inventory.find( ).sort( &#123; &quot;stock.size&quot;: 1, &quot;stock.quantity&quot;: 1 &#125; )</div><div class="line">db.inventory.find( &#123; &quot;stock.size&quot;: &quot;M&quot; &#125; ).sort( &#123; &quot;stock.quantity&quot;: 1 &#125; )</div></pre></td></tr></table></figure>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>了解索引只是我们使用的第一步，我们最终的目的是能够高效的利用它们，因此，我们在创建索引的时候就要很清楚的知道，哪些查询是完全无法使用索引的，哪些查询是可以比其他查询能够更高效使用索引的。为了能够达到这一点，我们就需要了解MongoDB对各种不同查询操作符是怎么处理的。</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="$操作符"></a>$操作符</h3><p><strong>$where</strong><br>这种情况是完全无法使用索引，索引查询中尽量避免使用<code>$where</code>。</p>
<p><strong>$exists</strong><br>无法使用索引，因为在索引中，不存在的字段和null字段的存储方式是一样的，查询必须遍历每一个文档检查这个值是否真的为null还是根本不存在。</p>
<p><strong>$ne</strong><br>可以使用索引，但是不高效，因为要查看所有的索引条目。</p>
<p><strong>$not</strong><br>有时能使用索引，但通常MongoDB并不知道如何去使用，对与基本的范围查询和正则表达式查询，MongoDB会进行反转，例如<code>{&quot;key&quot;: {&quot;$lt&quot;: 7}}</code>会变成<code>{&quot;key&quot;: {&quot;$gte&quot;: 7}}</code>，但是大部分时候这种查询会退化为全表扫描。</p>
<p><strong>$nin</strong><br>这个查询和<code>$where</code>的行为一样，总是会进行全表扫描，因此也要极力避免使用。</p>
<h3 id="何时不使用索引"><a href="#何时不使用索引" class="headerlink" title="何时不使用索引"></a>何时不使用索引</h3><p>大部分时候，索引都可以帮助我们高效的获取结果，但也有一些查询不使用索引会更快。因为使用索引需要进行两次查询，一次是查找索引条目，一次是根据索引指针去查找相应的文档，所以，如果我们要查找的结果集在原集合中所占的比例越大，索引的速度就越慢，而全表扫描只进行一次文档的查找。一般来说，如果查询需要返回集合内30%或者更多的数据，就需要对使用索引和全表扫描的速度进行比较，从而决定是否需要使用索引。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;索引的重要性，应该无需多说了，它可以优化我们的查询，而且在某些特定类型的查询中，索引几乎是必不可少的。这篇文章主要介绍了MongoDB中的几种常见的索引以及在使用时候的一些注意事项。这几种索引基本上涵盖了我们在平时开发的时候会遇到的大部分情况，但是，仍然需要注意的是，这篇文
    
    </summary>
    
    
      <category term="mongo" scheme="http://iszhenyu.me/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>python中的datetime模块</title>
    <link href="http://iszhenyu.me/posts/2016-09-07-python%E4%B8%AD%E7%9A%84datetime%E6%A8%A1%E5%9D%97.html"/>
    <id>http://iszhenyu.me/posts/2016-09-07-python中的datetime模块.html</id>
    <published>2016-09-07T06:17:32.000Z</published>
    <updated>2016-09-07T10:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timedelta"><a href="#timedelta" class="headerlink" title="timedelta"></a>timedelta</h2><h3 id="timedelta的实例化"><a href="#timedelta的实例化" class="headerlink" title="timedelta的实例化"></a>timedelta的实例化</h3><p>一个<code>timedalta</code>对象代表了一个时间差，当两个<code>date</code>或<code>datetime</code>进行相减操作时会返回一个<code>timedelta</code>对象，或者，我们也可以手动对其进行实例化，其构造函数的原型如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">datetime</span>.<span class="title">timedelta</span><span class="params">([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])</span></span></div></pre></td></tr></table></figure></p>
<p>其中，所有的参数都是可选的，并且默认为0，一般情况下，我们常用的是其中三个参数<code>days</code>、<code>seconds</code>、<code>microseconds</code>，如果我们传递了其他的几个参数值，python会帮助我们自动转换成上面三个参数，转换的规则是：</p>
<ul>
<li>1 millisecond（毫秒） 转换成 1000 microseconds（微秒）</li>
<li>1 minute 转换成 60 seconds</li>
<li>1 hour 转换成 3600 seconds</li>
<li>1 week转换成 7 days</li>
</ul>
<p>如果我们在实例化的时候直接传递的是上面三个参数值，那么也要注意下它们的取值范围：</p>
<ul>
<li>0 &lt;= microseconds &lt; 1000000</li>
<li>0 &lt;= seconds &lt; 3600*24 (一天的秒数)</li>
<li>-999999999 &lt;= days &lt;= 999999999</li>
</ul>
<p>那么，如果我们在传递这三个参数的时候超出了这个范围会有什么问题吗，答案是不一定，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = datetime.timedelta(seconds=<span class="number">86400</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.days</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.seconds</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>可以看到，如果超过范围，python是会帮我们自动转换的，但是如果<code>days</code>参数超出范围会有什么结果呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ee = datetime.timedelta(days=<span class="number">1000000000</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">OverflowError: days=<span class="number">1000000000</span>; must have magnitude &lt;= <span class="number">999999999</span></div></pre></td></tr></table></figure></p>
<p>所以，只有<code>days</code>是不能超出范围的，否则会抛出<code>OverflowError</code>异常。</p>
<p>在实例化的时候，参数不仅仅可以是整数，也可以是浮点数、正数或者负数，当参数为负数的时候，要特别注意，因为生成的样式也许与我们设想的不太一致<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = datetime.timedelta(microseconds=<span class="number">-1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.days, tmp.seconds, tmp.microseconds</div><div class="line">(<span class="number">-1</span>, <span class="number">86399</span>, <span class="number">999999</span>)</div></pre></td></tr></table></figure></p>
<p>所以，我们传递参数的时候，尽量避免传递负数的情况，同样，我们也应该极力避免传递的参数为浮点数，我们在使用的时候一般以秒作为单位就能满足99%的需求了。</p>
<h3 id="timedelta的运算"><a href="#timedelta的运算" class="headerlink" title="timedelta的运算"></a>timedelta的运算</h3><h4 id="操作"><a href="#操作" class="headerlink" title="+ 操作"></a><code>+</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = datetime.timedelta(seconds=<span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = datetime.timedelta(seconds=<span class="number">30</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t3 = t1 + t2</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t3.seconds</div><div class="line"><span class="number">90</span></div></pre></td></tr></table></figure>
<h4 id="操作-1"><a href="#操作-1" class="headerlink" title="- 操作"></a><code>-</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t4 = t1 -t2</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t4.seconds</div><div class="line"><span class="number">30</span></div></pre></td></tr></table></figure>
<h4 id="操作-2"><a href="#操作-2" class="headerlink" title="* 操作"></a><code>*</code> 操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t5 = t1 * <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t5</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">120</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t6 = t1 * <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t6</div><div class="line">datetime.timedelta(<span class="number">0</span>)</div></pre></td></tr></table></figure>
<h4 id="或-操作"><a href="#或-操作" class="headerlink" title="/ 或 //操作"></a><code>/</code> 或 <code>//</code>操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 / <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">20</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 / <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">8</span>, <span class="number">571428</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7 = t1 // <span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t7</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">8</span>, <span class="number">571428</span>)</div></pre></td></tr></table></figure>
<p>注意这里的被除数不能是0，否则会抛出<code>ZeroDivisionError</code>。</p>
<h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &gt; t2</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &lt; t2</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2</div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == <span class="number">60</span></div><div class="line"><span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 != <span class="number">60</span></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1 &gt; <span class="number">60</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: can<span class="string">'t compare datetime.timedelta to int</span></div></pre></td></tr></table></figure>
<p>可以看到，两个<code>timedelta</code>对象可以直接进行比较操作，而一个<code>timedelta</code>对象与一个非<code>timedelta</code>对象进行<code>==</code>或<code>!=</code>操作时总是返回<code>False</code>，而进行<code>&gt;</code>或<code>&lt;</code>操作则会抛出<code>TypeError</code>。</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>+t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>-t1</div><div class="line">datetime.timedelta(<span class="number">-1</span>, <span class="number">86340</span>)</div><div class="line"></div><div class="line">// 返回的格式为[D day[s], ][H]H:MM:SS[.UUUUUU]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(t1)</div><div class="line"><span class="string">'0:01:00'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>str(-t1)</div><div class="line"><span class="string">'-1 day, 23:59:00'</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>repr(t1)</div><div class="line"><span class="string">'datetime.timedelta(0, 60)'</span></div></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在2.7版本后，新增了一个方法<code>timedelta.total_seconds()</code>用于计算秒数，它等价于<code>(td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1</div><div class="line">datetime.timedelta(<span class="number">0</span>, <span class="number">60</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t1.total_seconds()</div><div class="line"><span class="number">60.0</span></div></pre></td></tr></table></figure></p>
<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>一个<code>date</code>对象代表使用年、月、日表示的时间，我们可以只用年、月、日三个值直接构造一个<code>date</code>对象，且这三个参数缺一不可，它们的取值范围如下</p>
<ul>
<li>MINYEAR &lt;= year &lt;= MAXYEAR</li>
<li>1 &lt;= month &lt;= 12</li>
<li>1 &lt;= day &lt;= 给定年月的天数</li>
</ul>
<p>如果我们传递的参数超出这个范围，将会抛出<code>ValueError</code>异常。除了手动传入年、月、日来构造<code>date</code>对象外，系统还提供了静态方法，我们可以使用这些静态方法来方便的得到一个<code>date</code>对象</p>
<ul>
<li><p>date.today()<br>返回当前的本地时间，等价于<code>date.fromtimestamp(time.time())</code></p>
</li>
<li><p>date.fromtimestamp(timestamp)</p>
</li>
</ul>
<p>当得到<code>date</code>对象后，就可以直接访问它的年、月、日属性了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = date.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.year</div><div class="line"><span class="number">2016</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.month</div><div class="line"><span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.day</div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p>
<h3 id="运算与比较操作"><a href="#运算与比较操作" class="headerlink" title="运算与比较操作"></a>运算与比较操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>delta = timedelta(days=<span class="number">7</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future = today + delta</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">8</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future - delta</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future - today</div><div class="line">datetime.timedelta(<span class="number">7</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>future &gt; today</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>date</code>可以作为字典的key，并且，所有的<code>date</code>对象都会被认为是<code>True</code>的，也就是 if date 这个判断永远是成立的。</p>
</blockquote>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li><p>date.replace(year, month, day)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">datetime.date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">31</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.replace(day=<span class="number">26</span>)</div><div class="line">datetime.date(<span class="number">2002</span>, <span class="number">12</span>, <span class="number">26</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>date.weekday()<br>返回一周的礼拜几，用int值表示，从0开始</p>
</li>
<li>date.isoweekday()<br>返回一周的礼拜几，用int值表示，从1开始</li>
<li>date.isoformat()<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d.isoformat()</div><div class="line"><span class="string">'2002-12-31'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><code>datetime</code>从字面意思上看是<code>date</code>和<code>time</code>的结合，而实际上也是包含了这两个对象的全部信息，我们可以手动构造<code>datetime</code>对象，也可以使用系统提供的静态方法，当我们手动构造的时候，必须要传入<code>year</code>、<code>month</code>和<code>day</code>三个参数，他们的取值范围与上面讲到的<code>date</code>对象一致。</p>
<p>我们在处理时间问题时，始终无法回避的是时区问题，在python中，使用<code>datetime.tzinfo</code>来表示时区，但这是一个抽象基类，python也并没帮我们实现任意的时区，因此，我们首先来看下在不涉及时区的时候<code>datetime</code>都有哪些用法，然后我们会创建一个本地时区，也就是东八区，来说明<code>datetime</code>如何与<code>tzinfo</code>结合使用。</p>
<h3 id="datetime对象的创建"><a href="#datetime对象的创建" class="headerlink" title="datetime对象的创建"></a>datetime对象的创建</h3><p>我们可以通过指定年月日的形式来手动创建一个<code>datetime</code>实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>cur = datetime(year=<span class="number">2016</span>, month=<span class="number">9</span>, day=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>cur</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>也可以直接通过静态方法来获的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.today()</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">21</span>, <span class="number">810692</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.now()</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">50</span>, <span class="number">34</span>, <span class="number">89763</span>)</div></pre></td></tr></table></figure></p>
<p>这两个方法都会返回一个本地当前时间，也就是上面的两个写法是等效的，但是要注意的是，<code>now()</code>方法可以传入时区信息，我们稍后再一起讨论。</p>
<p>除了上面的方法，我们还可以通过时间戳来获取一个对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.fromtimestamp(time.time())</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">54</span>, <span class="number">56</span>, <span class="number">65907</span>)</div></pre></td></tr></table></figure></p>
<p>我们这里同样暂不考虑时区的问题。<br>除了通过时间戳获取<code>datetime</code>实例外，我们还可以通过一个格式化的时间字符串来获得实例，这个方法同样是不带时区信息的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.strptime(<span class="string">'2016-09-02 18:00:00'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>既然一个<code>datetime</code>对象包含了<code>date</code>和<code>time</code>的所有信息，那么能不能通过这两对象来生成一个<code>datetime</code>实例呢，答案是肯定的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = date(year=<span class="number">2016</span>, month=<span class="number">9</span>, day=<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = time(hour=<span class="number">18</span>, minute=<span class="number">14</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line">datetime.time(<span class="number">18</span>, <span class="number">14</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.combine(d, t)</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">14</span>)</div></pre></td></tr></table></figure></p>
<p>现在<code>datetime</code>也有了，我们总要在它身上做点什么吧，能做什么呢？</p>
<h3 id="常用方法介绍"><a href="#常用方法介绍" class="headerlink" title="常用方法介绍"></a>常用方法介绍</h3><p>有了<code>datetime</code>对象之后，我们就可以获得对应的<code>date</code>和<code>time</code>对象了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = datetime.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.date()</div><div class="line">datetime.date(<span class="number">2016</span>, <span class="number">9</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today.time()</div><div class="line">datetime.time(<span class="number">18</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">304536</span>)</div></pre></td></tr></table></figure></p>
<p>那如果我希望得到下个月的今天，该怎么做呢？方法有多种，但是最方便的是直接把月份进行加一操作（不考虑跨年和日期超过月份最大值的情况），这个时候<code>replace</code>函数就派上用场了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month = today.replace(month=today.month+<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month</div><div class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">304536</span>)</div></pre></td></tr></table></figure></p>
<p><code>replace()</code>方法允许我们对<code>datetime</code>的任意字段进行替换，并返回一个新的<code>datetime</code>对象，这个新的对象在其他字段上与原有对象保持一致。</p>
<p>除此之外，还有一个比较常用的方法<code>strftime()</code>，通过它可以格式化成我们希望的样式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>next_month.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"><span class="string">'2016-10-02 18:30:10'</span></div></pre></td></tr></table></figure></p>
<p>还有一种情况，是我们希望将一个<code>datetime</code>对象转成时间戳，很遗憾的是python并没直接提供这个方法，但是提供了一个<code>timetuple()</code>方法，它返回一个<code>time.struct_time</code>对象，通过它我们可以构造出时间戳了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>dd = datetime.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tt = time.mktime(dd.timetuple())</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> int(tt)</div><div class="line"><span class="number">1472816083</span></div></pre></td></tr></table></figure></p>
<h3 id="时区的定义"><a href="#时区的定义" class="headerlink" title="时区的定义"></a>时区的定义</h3><p>python中给我们提供了<code>datetime.tzinfo</code>这一抽象的基类，如果我们想使用时区，则必须继承这个类来实现自己的时区定义。我们先来看下都有哪些方法可能需要我们来实现</p>
<ul>
<li><code>tzinto.utcoffset(self, dt)</code> </li>
</ul>
<p>这个方法返回本地时间与UTC时间的时差，我们知道，我们国家使用的是东八区，也就是比世界协调时间（UTC）/格林尼治时间（GMT）快8小时的时区，因此我们可以如下实现这个方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utcoffset</span><span class="params">(self, dt)</span>:</span></div><div class="line">    <span class="keyword">return</span> timedelta(hours=<span class="number">8</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li><code>tzinfo.dst(self, dt)</code></li>
</ul>
<p>这个方法主要是考虑到一些采用夏令时的国家，在固定月份来调整时间，而我们国家是没有采用夏令时，所以直接返回0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dst</span><span class="params">(self, dt)</span>:</span></div><div class="line">    <span class="keyword">return</span> timedelta(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>而对于采纳了夏令时的国家，则需要把夏令时考虑进去<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dst</span><span class="params">(self, dt)</span>:</span></div><div class="line">    <span class="comment"># Code to set dston and dstoff to the time zone's DST</span></div><div class="line">    <span class="comment"># transition times based on the input dt.year, and expressed</span></div><div class="line">    <span class="comment"># in standard local time.  Then</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> dston &lt;= dt.replace(tzinfo=<span class="keyword">None</span>) &lt; dstoff:</div><div class="line">        <span class="keyword">return</span> timedelta(hours=<span class="number">1</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> timedelta(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>对于这些国家，我还要修改<code>utcoffset</code>函数，将夏令时的偏移量考虑进去<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">utcoffset</span><span class="params">(self, dt)</span>:</span></div><div class="line">    <span class="keyword">return</span> timedelta(hours=N) + self.dst(dt)</div></pre></td></tr></table></figure></p>
<ul>
<li><code>tzinfo.tzname(self, dt)</code></li>
</ul>
<p>这个方法用来返回时区的名称，没有太多可说的</p>
<p>一般情况下，我们只要实现上面三个方法就可以了，例如我们可以这样定义一个UTC时区和我们所在的东八区<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ZERO = timedelta(<span class="number">0</span>)</div><div class="line">HOUR = timedelta(hours=<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UTC</span><span class="params">(tzinfo)</span>:</span></div><div class="line">    <span class="string">"""UTC"""</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">utcoffset</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> ZERO</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tzname</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"UTC"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dst</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> ZERO</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GMT8</span><span class="params">(tzinfo)</span>:</span></div><div class="line">    <span class="string">"""东八区""</span></div><div class="line"></div><div class="line">    def utcoffset(self, dt):</div><div class="line">        return HOUR * 8</div><div class="line"></div><div class="line">    def tzname(self, dt):</div><div class="line">        return 'GMT-8'</div><div class="line"></div><div class="line">    def dst(self, dt):</div><div class="line">        return ZERO</div></pre></td></tr></table></figure></p>
<p>除了我们自己来定义时区外，我们还可以使用<code>pytz</code>这个模块，通过<code>easy_install</code>命令直接安装即可。</p>
<h3 id="datetime与时区的结合使用"><a href="#datetime与时区的结合使用" class="headerlink" title="datetime与时区的结合使用"></a>datetime与时区的结合使用</h3><p>我们上面已经介绍了在不考虑时区因素的时候，<code>datetime</code>的一些简单用法，接下来看下加入时区后，有哪些不一样的地方，以及我们需要注意的地方。</p>
<p>我们在上面提到了类方法<code>now</code>，在不考虑时区的时候，它的作用和类方法<code>today</code>基本是一致的，我们也可以在使用<code>now</code>的时候传递一个<code>tzinfo</code>，如下的两种方式是等效的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">today = datetime.today()</div><div class="line">today = today.replace(tzinfo=GMT8())</div><div class="line">// 等效于</div><div class="line">today = datetime.now(GMT8())</div></pre></td></tr></table></figure></p>
<p>除了<code>now()</code>方法外，系统还提供了<code>utcnow()</code>方法，这个方法没有参数，返回的是UTC的时间，但是要注意的是，这个方法创建的<code>datetime</code>对象同样是不带时区信息的。</p>
<p>到目前为止，我们都还不知道时区到底有什么作用，假设说我们现在有这样的需求：在数据库中记录的时间全部采用UTC时间，而在展示的时候需要转换成本地时间。我们在查库后，一些ORM（例如：SQLAlchemy）会自动帮我们将时间值转化成<code>datetime</code>对象，但这些<code>datetime</code>都是不带时区信息的，如果我们想转化成本地时间则必须要创建本地的时区<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">today = datetime.utcnow()</div><div class="line">today = today.replace(tzinfo=UTC())</div><div class="line"><span class="keyword">print</span> today //<span class="number">2016</span><span class="number">-09</span><span class="number">-06</span> <span class="number">06</span>:<span class="number">47</span>:<span class="number">42.665574</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line"></div><div class="line">today = today.astimezone(GMT8())</div><div class="line"><span class="keyword">print</span> today //<span class="number">2016</span><span class="number">-09</span><span class="number">-06</span> <span class="number">14</span>:<span class="number">47</span>:<span class="number">42.665574</span>+<span class="number">08</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p>
<p>如上所示，系统提供了<code>datetime.astimezone(tz)</code>方法，使用这个方法可以在各个时区之间来回转换时间。这里有两点需要注意：</p>
<ul>
<li>如果<code>datetime</code>对象本身没有包含时区信息，调用这个方法会抛出<code>ValueError</code>，并提示<code>astimezone() cannot be applied to a naive datetime</code></li>
<li><code>replace(tzinfo=...)</code>方法只会替换<code>tzinfo</code>的值，并不会更改时分秒等时间信息</li>
</ul>
<p>最后，还有两个通过时间戳获取<code>datetime</code>的类方法，<code>datetime.fromtimestamp(timestamp[, tz])</code>和<code>datetime.utcfromtimestamp(timestamp)</code>，<code>utcfromtimestamp</code>得到的是一个UTC时间，并且不带<code>tzinfo</code>信息，除此之外，两者并无太大区别。</p>
<p>到这里，<code>datetime</code>模块的大部分方法就介绍完了，还有一些我们不是很常用的方法，大家可以自行看看文档了解下就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timedelta&quot;&gt;&lt;a href=&quot;#timedelta&quot; class=&quot;headerlink&quot; title=&quot;timedelta&quot;&gt;&lt;/a&gt;timedelta&lt;/h2&gt;&lt;h3 id=&quot;timedelta的实例化&quot;&gt;&lt;a href=&quot;#timedelta的实例
    
    </summary>
    
    
      <category term="python" scheme="http://iszhenyu.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Android中与js进行交互</title>
    <link href="http://iszhenyu.me/posts/2016-07-01-Android%E4%B8%AD%E4%B8%8Ejs%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html"/>
    <id>http://iszhenyu.me/posts/2016-07-01-Android中与js进行交互.html</id>
    <published>2016-07-01T09:53:49.000Z</published>
    <updated>2016-09-07T06:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发Android应用的时候，很多的时候需要跟网页打交道，假如我们现在在做一个外卖app，在app首页会有一个轮询的广告位，我们点击其中一项会跳转至一个wap网页，在这个网页里可能会有几个餐厅的推广信息，在用户点击某个餐厅后，我们希望跳出wap页面展示餐厅的详情，这个时候就需要用到js调用java代码来实现了。再或者，如果我们需要在wap页中进行分享可能也需要用js调用java代码来执行分享的操作。类似这样的场景很多，如果我们需要实现这种功能，就要了解java和js之间的交互的方法。</p>
<h2 id="WebView的使用"><a href="#WebView的使用" class="headerlink" title="WebView的使用"></a>WebView的使用</h2><p>我们在Android中如果希望展示一个网页，基本上都会使用WebView这个组件，它的基本使用也很简单，假如我们希望加载一下百度首页，可以像下面这样写： 首先在layout文件中进行声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    &gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">WebView</span> </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在java文件中进行使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WebView webView = (WebView) findViewById(R.id.web_view);</div><div class="line">webView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</div></pre></td></tr></table></figure>
<p>同时，WebView还允许我们对一些默认设置进行修改，例如，我们希望启动对javascript的支持并且可以进行缩放，就需要做如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 启用javascript</span></div><div class="line">webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//是否可以缩放</span></div><div class="line">webView.getSettings().setSupportZoom(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setBuiltInZoomControls(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; </div><div class="line">    getSettings().setDisplayZoomControls(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们想要在页面加载的时候处理各种通知、请求事件，或者监听页面的加载进度等，就需要用到另外两个类：WebViewClient 和 WebChromeClient。其中，WebViewClient 主要用来监听通知或请求事件，我们在开发中可能会用到的方法主要是下面几个：</p>
<ul>
<li>onPageStarted</li>
<li>onPageFinished</li>
<li>onReceivedError</li>
<li>shouldOverrideUrlLoading</li>
</ul>
<p>而 <code>WebChromeClient</code> 则用来处理javascript、网站图标、网站title和加载进度等，我们在使用微信时，如果打开一个网页，会看到它的上面有一条绿色的进度条，这个功能就是通过重写 <code>WebChromeClient</code> 的 <code>onProgressChanged</code>方法来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebClient</span> <span class="keyword">extends</span> <span class="title">WebChromeClient</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(WebView view, <span class="keyword">int</span> newProgress)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (newProgress == <span class="number">100</span>) &#123; </div><div class="line">            mProgressBar.setVisibility(GONE); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">if</span> (mProgressBar.getVisibility() == GONE) &#123; </div><div class="line">                mProgressBar.setVisibility(VISIBLE); </div><div class="line">            &#125; </div><div class="line">            mProgressBar.setProgress(newProgress);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">super</span>.onProgressChanged(view, newProgress); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，WebView还提供了直接运行javascript的功能，例如，我们可以简单的弹出一个对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.loadUrl(<span class="string">"javascript:alert(\"提示信息！\");"</span>);</div></pre></td></tr></table></figure>
<p>当然，如果我们想要执行js，那么必须满足两个条件，第一个是在设置中开启javascript支持，即需要调用<code>setJavascriptEnabled(true)</code>，第二个是需要设置<code>WebChromeClient</code>，两者缺一不可。</p>
<p>在一些比较复杂的场景下，我们要做的不再是简单的显示一个页面而已，大多时候，我们更希望通过javascript来访问app内的一些数据，或者与app进行交互。我们尝试定义这样一个组件，希望可以通过它来达到我们的目的，我们暂且对这样的组件起名为<code>WebViewJavascriptBridge</code>。</p>
<h2 id="WebViewJavascriptBridge设计思路"><a href="#WebViewJavascriptBridge设计思路" class="headerlink" title="WebViewJavascriptBridge设计思路"></a>WebViewJavascriptBridge设计思路</h2><p>根据第二节的介绍，对于第一种情况，也就是通过java来调用javascript代码，系统已经帮我们实现好了，但是第二种情况系统却没有直接提供实现。 尽管如此，我们可以考虑是否能在 <code>WebViewClient</code> 或 <code>WebChromeClient</code> 中寻得突破口。在 <code>WebViewClient</code> 中存在这样一个方法: <code>shouldOverrideUrlLoading(WebView view, String url)</code>，在这个方法的注释中是这样说的：</p>
<blockquote>
<p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView.</p>
</blockquote>
<p>也就是说，对于在WebView中的每个请求，我们都是有机会对其进行拦截的，并且接管本次请求。 我们比较熟悉的是通过一个url来访问页面，比如我们在访问美团网的时候，它的一个团购单的url可能是这个样子 <code>http://bj.meituan.com/deal/25709595.html</code>，而url本身是可以携带一些信息的，上面这个url还不是很明显，如果我们换种写法，你就会看的更清楚些 <code>http://bj.meituan.com/?deal=25709595</code>当然这个链接并不能正常访问到团购页，这里只是做个示意，也就是说我们是可以通过这种param的形式来传递一些数据的。 而我们又可以在 <code>WebViewClient</code> 中对这个请求进行拦截，在拦截方法中我们是能够拿到本次请求的url中所传递过来的数据的，根据这些请求过来的数据，就可以执行本地java代码来处理了，处理完毕后，通过WebView又可以通过回调javascript的方式来返回结果。 以上就是我们实现 <code>WebViewJavascriptBridge</code> 的主要思路了，当然在具体实现的时候会有一些细节，这个我们在下一节具体实现的时候再继续探讨。<br>总结一下，1、java调用javascript可以直接调用。2、javascript调用java需要用到 <code>WebViewClient</code>。我们用下图更直观的表示下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2368004-9ab4b678dc70ba52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java与javascript交互示意.jpg"></p>
<h2 id="WebViewJavascriptBridge具体实现"><a href="#WebViewJavascriptBridge具体实现" class="headerlink" title="WebViewJavascriptBridge具体实现"></a>WebViewJavascriptBridge具体实现</h2><p>我们知道，一个标准的URL的格式应该是下面这个样子：</p>
<blockquote>
<p>protocol://hostname[:port]/path/[;parameters][?query]#fragment</p>
</blockquote>
<p>我们在访问页面的时候，用到的最多的协议就是<code>http</code>和<code>https</code>了，除了这两个协议外，还有<code>file</code>、<code>ftp</code>等等。这里我们自己来定义一个协议名称，所有javascript调用java的代码都走这个协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CUSTOM_PROTOCOL_SCHEME = <span class="string">"wvjbscheme"</span>; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCorrectProtocolScheme</span><span class="params">(String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(url)) &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> url.startsWith(CUSTOM_PROTOCOL_SCHEME + <span class="string">"://"</span>);   </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的好处就是，我们在对请求进行拦截后，可以更方便的分辩出哪些是需要自己处理的，而对哪些正常的网络请求放行。因此，我们可以定义一个<code>WebViewClient</code>的子类，并重写它的<code>shouldOverrideUrlLoading</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> WebViewJsBridgeBase base; </div><div class="line">    <span class="keyword">private</span> WebViewClient mWebViewClient; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            url = URLDecoder.decode(url, <span class="string">"UTF-8"</span>); </div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">            <span class="comment">// do nothing </span></div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">            ... </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">return</span> mWebViewClient.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们会去判断是否是我们自定义的协议，如果不是还会判断mWebViewClient是否为空，这里为什么还要定义一个WebViewClient呢？原因也很简单，<code>WebView</code>只能设置一个<code>WebViewClient</code>，我们这里已经定义了<code>WebViewClient</code>如果用户还需要自己定义怎么办呢？所以这里持有了一个用户自定义的<code>WebViewClient</code>，通过这个client就可以将一些事件转发出去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            mWebViewClient.onPageStarted(view, url, favicon); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">super</span>.onPageStarted(view, url, favicon); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，我们回到Bridge的实现问题上来。在一个页面加载完毕后，如果我们想使用javascript来调用java，那么前期的一些准备工作是必不可少的，因为我们这里说的javascript调用java并不是将javascript代码转化为java执行，而更像是一种曲线救国的方式，因此，至少我们要约定一下，javascript的哪个方法可以调用java对应的哪个方法，也就是我们对其进行一些初始化操作。</p>
<p>我们将java可以处理的每个问题抽象为一个Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBHandler</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>WVJBResponseCallback</code>也是一个接口，当<code>Handler</code>处理完毕后就是通过这个<code>callback</code>来进行回调给javascript端的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBResponseCallback</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(String responseData)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们定义的这两个接口里面，数据是按照String的格式进行传输的，因为javascript天生支持json，因此，对于一些复杂的数据类型，都可以转化为json字符串。</p>
<p>我们的初始化操作就包括注册这些Handler，也就是声明java端可以处理哪些问题，因为会有多个Handler，也就会有多个Callback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    Map&lt;String, WVJBResponseCallback&gt; responseCallbacks; </div><div class="line">    Map&lt;String, WVJBHandler&gt; messageHandlers; </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridge</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String handlerName, WVJBHandler handler)</span> </span>&#123; </div><div class="line">        base.messageHandlers.put(handlerName, handler); </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到目前为止，我们一直都是在讲java端的一些实现，那在js端到底要怎么样才能调用我们定义好的Handler呢？</p>
<p>通过上面的介绍，如果希望调用java代码，那么必须发起一个请求，在页面中我们发起请求的方式有几种，最常规的是点击一个链接进行跳转，还可以通过javascript来发起一个ajax请求，除此之外，我们还可以借助iframe，就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">WVJBIframe.style.display = <span class="string">'none'</span>;</div><div class="line">WVJBIframe.src = <span class="string">'wvjbscheme://__BRIDGE_LOADED__'</span>;</div><div class="line"><span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</div></pre></td></tr></table></figure>
<p>我们在原页面里面添加了一个隐藏的iframe元素，所有需要跟java交互的请求都是通过改变这个iframe的src属性来实现的。</p>
<p>假设说我们现在需要实现一个功能，是在页面里有一个分享按钮，点击这个分享按钮后，打开app自己的分享功能。</p>
<p>第一步，我们需要实现这样一个Handler ，并且将其注册到Bridge中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bridge.registerHandler(<span class="string">"share_handler"</span>, <span class="keyword">new</span> WVJBHandler() &#123;   </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span> </span>&#123; </div><div class="line">        Log.d(<span class="string">"share info from js : "</span>, data); </div><div class="line">        callback.callback(<span class="string">"share success"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二步，在js中，我们通过一个<code>callHandler</code>方法来请求java代码的执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">'function'</span>) &#123; </div><div class="line">        responseCallback = data; </div><div class="line">        data = <span class="literal">null</span>; </div><div class="line">    &#125; </div><div class="line">    _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (responseCallback) &#123; </div><div class="line">        <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span>+(uniqueId++)+<span class="string">'_'</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </div><div class="line">        responseCallbacks[callbackId] = responseCallback; </div><div class="line">        message[<span class="string">'callbackId'</span>] = callbackId; </div><div class="line">    &#125; </div><div class="line">    sendMessageQueue.push(message); </div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们在这里构造了一个Message对象，这个对象包含三个属性，一个是需要java处理的Handler名称，一个是data数据本身，还有是一个回调方法的id，这个回调方法就是java在执行完毕后的回调方法。此外，我们提供了一个Queue来保存这些请求的Message对象，之后通知java有Message进入到队列里面。<br>第三步，<code>WebViewClient</code>对这个请求进行拦截，并到javascript的queue中去取Message：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean shouldOverrideUrlLoading(WebView view, <span class="built_in">String</span> url) &#123; </div><div class="line">    ... </div><div class="line">    if (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        if (base.isQueueMessageUrl(url)) &#123; </div><div class="line">            <span class="built_in">String</span> javascriptCommand = base.javascriptFetchQueryCommand(); </div><div class="line">            bridge.evaluateJavascript(javascriptCommand); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        return <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在Android中执行javascript后不会反回结果，所以为了拿到Message对象，我们需要将这个Message对象像参数一样附在请求的后面传递给java：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_fetchQueue</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(sendMessageQueue); </div><div class="line">    sendMessageQueue = []; </div><div class="line">    <span class="comment">// android 不能直接返回结果,做在放在url中返回 </span></div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + RETURN_WITH_MESSAGE + <span class="string">'/'</span> + messageQueueString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，这个请求会再次被<code>WebViewClient</code>拦截，并解析<code>Message</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        <span class="keyword">if</span> (base.isReturnMessageUrl(url)) &#123; </div><div class="line">            String messageQueueString = base.messageQueueStringFromReturnUrl(url); </div><div class="line">            base.flushMessageQueue(messageQueueString); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>flushMessageQueue</code>方法中，主要执行的就是解析Message，并调用对应的Handler来进行处理，在处理完毕后，回调javascript的callback方法返回结果。到此，java与javascript的一个完整的交互流程就完成了。更完整的代码可以参考：<a href="https://github.com/xiaoza/WebViewJavascriptBridgeForAndroid" target="_blank" rel="external">WebViewJavascriptBridgeForAndroid</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在开发Android应用的时候，很多的时候需要跟网页打交道，假如我们现在在做一个外卖app，在app首页会有一个轮询的广告位，我们点击其
    
    </summary>
    
    
      <category term="android" scheme="http://iszhenyu.me/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Picasso源码解析</title>
    <link href="http://iszhenyu.me/posts/2016-06-29-Picasso%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"/>
    <id>http://iszhenyu.me/posts/2016-06-29-Picasso源码解析.html</id>
    <published>2016-06-29T03:22:07.000Z</published>
    <updated>2016-09-07T06:13:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Picasso作为一个非常棒的android第三方图片加载库，在Github上获得了高达7000多的star。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context).load(“image url”).into(imageView);</div></pre></td></tr></table></figure>
<p>这么简单的一行代码就完成了在Android中加载图片的功能，这其中，Picasso还帮我们自动完成了一些android中处理图片的问题：例如在adapter中ImageView的回收和取消下载，使用最小的内存来完成图片的过渡，自动的内存和磁盘缓存等，的确是非常简单的。</p>
<p>但作为开发人员，简单的会用是不够的，毕竟我们在实际项目中可能会遇到各种奇葩问题，这个时候就有必要深入到内部一探究竟了。下面就从源码的角度来讲解一下Picasso的工作原理。我们可以直接在github上 clone下整个Picasso项目或者如果你使用的是studio的gradle依赖管理，那么也可以直接在项目的Extension Library中查看Picasso的源码。</p>
<p>我们先看下上面一行代码中用到的三个函数，首先是with函数，它的实现是这个样子的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Content context)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">synchronized</span> (Picasso.class) &#123;</div><div class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Builder().build();</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> singleton;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">可以看到Picasso使用的是单例模式，并且使用Builder模式创建了一个Picasso的实例，具体如何创建的我们这里先不管，继续往下看。</div><div class="line">有了这个的实例之后，直接调用了它的load函数，Picasso重载了几个不同参数的load函数，用以从不同的地点来加载图片：</div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(Uri uri)</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(<span class="keyword">int</span> resourceId)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过load函数，我们最终得到了一个RequestCreator对象，通过这个对象我们就可以定制一些对图片的特殊处理了，这里我们同样不去深究这个RequestCreator内部是如果对图片进行处理的。<br>最后我们调用了into函数，将加载到的图片赋给一个ImageView控件。我们前面的操作可以说都是为into函数做准备，实际工作的开始，就是在into里面完成的。我们跟进<code>into</code>方法看一下，当然了，我们现在还是主要关注流程，不必过于深究细节，这个方法稍微有点长，但是为了方便起见，我们把它的代码贴在这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(Target target)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> started = System.nanoTime();</div><div class="line">    checkMain();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (deferred) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with a Target."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            picasso.cancelRequest(target);</div><div class="line">            target.onBitmapLoaded(bitmap, MEMORY);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable,</div><div class="line">            requestKey, tag, errorResId);</div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法稍微有些长，但是逻辑还是比较清晰的，我们总结一下：</p>
<ol>
<li>into会检查当前是否是在主线程上执行。</li>
<li>如果我们没有提供一个图片资源并且有设置placeholder，那么就会把我们设置的placeholder显示出来，并中断执行。</li>
<li>defered属性我们一般情况下不需要关注，只有当我们调用了RequestCreator的fit方法时defered才为true，但我们几乎不会这样做。</li>
<li>接下来就是创建了一个Request对象，我们在前面做得一些设置都会被封装到这个Request对象里面。</li>
<li>检查我们要显示的图片是否可以直接在缓存中获取，如果有就直接显示出来好了。</li>
<li>缓存没命中，那就只能费点事把源图片down下来了。这个过程是异步的，并且通过一个Action来完成请求前后的衔接工作。</li>
</ol>
<p>至此，Picasso在主线程中的工作就结束了。通过上面的分析，我们看到Picasso的思想还是很清晰的：首先通过Picasso创建了一个RequestCreator对象，通过这个对象我们可以针对不同的场景来设置一些属性，之后创建出Request对象，最后通过Action来确定异步请求并对请求结果做处理。</p>
<p>接下来，我们就深入到内部看下具体的执行。首先看下Picasso构造函数的声明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</div><div class="line">      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,</div><div class="line">      Bitmap.Config defaultBitmapConfig, <span class="keyword">boolean</span> indicatorsEnabled, <span class="keyword">boolean</span> loggingEnabled) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么多的参数，也基本上涵盖了Picasso内部所有重要的组件。同时我们也看到这个Picasso是不允许外部进行实例化的。在这里，Picasso使用了单例和建造者模式来完成Picasso的实例化，在Builder中实例化了Picasso所需要的这些组件，这里使用Builder模式的另一个好处就是可以让我们根据自己的需求来个性化定制组件。那这些组件到底都是做什么的呢，下面我们就一一探个究竟。</p>
<p>既然Picasso是通过Builder来实例化的，那我们就从build函数入手，看一下都做了哪些工作。同样，为了阅读方便，我们把build的代码贴在下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">        downloader = Utils.createDefaultDownloader(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line">        cache = <span class="keyword">new</span> LruCache(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</div><div class="line">        transformer = RequestTransformer.IDENTITY;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(cache);</div><div class="line"></div><div class="line">      Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>build结束后，就为Picasso创建了如下几个对象：<br>Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher，从名称上我们基本上已经能够猜测出来每个组件都是干嘛的。这些对象传递给Picasso的构造函数后，在构造函数的内部又创建了了不同的RequestHandler，用以对不用的图片资源进行加载。说了这么多是不是有点晕，别急，下面我们会对每个组件做介绍，一点点将Picasso的执行过程串起来。</p>
<p>我们先来看下Downloader：它是一个接口，规定了一些通用的方法，这也就意味着，我们可以提供自己的下载器，只要实现这个接口即可，Picasso的扩展能力还是很不错的。这里Picasso默认使用OkHttpClient来作为下载器，同样也是squareup公司开源的一个网络库。</p>
<p>Cache：Picasso的缓存，这里实例化的是LruCache，其内部使用的是LinkedHashMap</p>
<p>ExecutorService：这里Picasso实现了自己的PicassoExecutorService，它继承了ThreadPoolExecutor，也就是Picasso自己维护了一个线程池，用于异步加载图片。</p>
<p>RequestTransformer：主要是对RequestCreator创建的Request进行转换，默认对Request对象不做处理。</p>
<p>Stats：这个类只要是维护图片的一些状态</p>
<p>Dispatcher：从名字上就可以判断出来，这个类在这里起到了一个调度器的作用，图片要不要开始下载以及下载后Bitmap的返回都是通过这个调度器来执行的，后面我们会对它进行更加详细的讲解。</p>
<p>对Picasso几个核心类有了大致了解后，我们再来看它到底是如何执行一个异步请求，又是如何将执行结果返回的。<br>通过上面的分析我们知道，RequestCreator在into方法的最后会创建一个Action实例，然后调用Picasso的enqueueAndSubmit方法，而最终是调用了Dispatcher的dispatchSubmit方法，也就是我们前面说的，Dispatcher起到了调度器的作用。在Dispatcher内部，Dispatcher定义了DispatcherThread和DispatcherHandler两个内部类，并在Dispatcher的构造函数中对他们经行了实例化，所有的调度也都是通过handler异步的执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler,</div><div class="line">      Downloader downloader, Cache cache, Stats stats) &#123;</div><div class="line">    <span class="keyword">this</span>.dispatcherThread = <span class="keyword">new</span> DispatcherThread();</div><div class="line">    <span class="keyword">this</span>.dispatcherThread.start();</div><div class="line">    ...</div><div class="line">    <span class="keyword">this</span>.handler = <span class="keyword">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class="keyword">this</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，我们看到的dispatchSubmit方法就如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在handler中最终调用了performSubmit方法来触发一个图片的加载，那么我们来看一下这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class="line">        pausedActions.put(action.getTarget(), action);</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</div><div class="line">        hunter.attach(action);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</div><div class="line">    hunter.future = service.submit(hunter);</div><div class="line">    hunterMap.put(action.getKey(), hunter);</div><div class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</div><div class="line">        failedActions.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法并不发杂，主要是获得BitmapHunter实例，由这个实例来执行实际的下载操作。BitmapHunter本身是Runnable的一个实现，而这个实例最终是交由Picasso线程池进行运行的。</p>
<p>那么这个BitmapHunter加载图片完成或失败后是怎么通知UI的呢？我们前面提到Dispatcher在Picasso中起到了一个调度器的作用，当图片加载完毕后自然也是通过这个调度器来更新UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        updateThreadName(data);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">            log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = hunt();</div><div class="line">        <span class="comment">// 通过Dispatcher来处理结果</span></div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>() &#123; </div><div class="line">        <span class="comment">//各种异常处理</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>假如我们的图片成功下载下来了，接下来就看看这个图片是如何被渲染到ImageView中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过handler来发送一个message，我们再看消息处理函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_COMPLETE: &#123;</div><div class="line">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class="line">          dispatcher.performComplete(hunter);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们最终执行了performComplete方法。在这个方法了会自动处理图片的缓存问题，方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</div><div class="line">      cache.set(hunter.getKey(), hunter.getResult());</div><div class="line">    &#125;</div><div class="line">    hunterMap.remove(hunter.getKey());</div><div class="line">    batch(hunter);</div><div class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，Picasso并不是立即将图片显示出来，而是用到了一个批处理，其实就是把操作先暂存在一个list中，等空闲的时候再拿出来处理，这样做得好处也是尽量减少主线程的执行时间，一方面防止ANR，另一方面快速返回，响应页面的其他渲染操作，防止卡顿用户界面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handMessage中对应的处理方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</div><div class="line">          dispatcher.performBatchComplete();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，通过这个batch我们实际看到，最后还是调用了Dispatcher的方法来处理，但由于这个处理并非是在主线程（参考前面Dispatcher构造函数中Handler的实例化），因此我们还需要通过一个主线程的Handler来处理这个请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class="line">    batch.clear();</div><div class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class="line">    logBatch(copy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个mainThreadHandler是在Dispatcher实例化时由外部传递进来的，我们在前面的分析中看到，Picasso在通过Builder创建时会对Dispatcher进行实例化，在那个地方将主线程的handler传了进来，我们回到Picasso这个类，看到其有一个静态成员变量HANDLER，这样我们也就清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class="line">          <span class="comment">//noinspection ForLoopReplaceableByForEach</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class="line">            BitmapHunter hunter = batch.get(i);</div><div class="line">            hunter.picasso.complete(hunter);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>到这里，我们的图片马上就要显示出来了。我们前面提到，Picasso中一个Action提供了请求前后的衔接工作，对于我们现在的情况，Picasso使用了ImageViewAction来进行处理，也就是在ImageViewAction中的complete方法完成了最后的图片渲染工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</div><div class="line">          String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Context context = picasso.context;</div><div class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">      callback.onSuccess();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，到此，一个图片从开始下载到成功渲染到ImageView中整个流程就讲完了。其中，Dispatcher那块的调度有点绕，如果不是很理解，可以先熟悉下android中handler的用法，handler本身也是android提供给我们方便进行线程间通信的，就像Picasso的实现一样，善用handler可以帮助我们实现更加流畅的用户UI操作体验。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Picasso作为一个非常棒的android第三方图片加载库，在Github上获得了高达7000多的star。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
    
    </summary>
    
    
      <category term="android" scheme="http://iszhenyu.me/tags/android/"/>
    
  </entry>
  
</feed>
