<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android中与js进行交互 · zhenyu</title><meta name="description" content="Android中与js进行交互 - zhenyu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iszhenyu.me/atom.xml" title="zhenyu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xiaoza" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android中与js进行交互</h1><div class="post-info">Jul 1, 2016</div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发Android应用的时候，很多的时候需要跟网页打交道，假如我们现在在做一个外卖app，在app首页会有一个轮询的广告位，我们点击其中一项会跳转至一个wap网页，在这个网页里可能会有几个餐厅的推广信息，在用户点击某个餐厅后，我们希望跳出wap页面展示餐厅的详情，这个时候就需要用到js调用java代码来实现了。再或者，如果我们需要在wap页中进行分享可能也需要用js调用java代码来执行分享的操作。类似这样的场景很多，如果我们需要实现这种功能，就要了解java和js之间的交互的方法。</p>
<h2 id="WebView的使用"><a href="#WebView的使用" class="headerlink" title="WebView的使用"></a>WebView的使用</h2><p>我们在Android中如果希望展示一个网页，基本上都会使用WebView这个组件，它的基本使用也很简单，假如我们希望加载一下百度首页，可以像下面这样写： 首先在layout文件中进行声明</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    &gt;</div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">WebView</span> </span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/web_view"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后在java文件中进行使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WebView webView = (WebView) findViewById(R.id.web_view);</div><div class="line">webView.loadUrl(<span class="string">"http://www.baidu.com"</span>);</div></pre></td></tr></table></figure>
<p>同时，WebView还允许我们对一些默认设置进行修改，例如，我们希望启动对javascript的支持并且可以进行缩放，就需要做如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 启用javascript</span></div><div class="line">webView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//是否可以缩放</span></div><div class="line">webView.getSettings().setSupportZoom(<span class="keyword">true</span>);</div><div class="line">webView.getSettings().setBuiltInZoomControls(<span class="keyword">true</span>);</div><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; </div><div class="line">    getSettings().setDisplayZoomControls(<span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，如果我们想要在页面加载的时候处理各种通知、请求事件，或者监听页面的加载进度等，就需要用到另外两个类：WebViewClient 和 WebChromeClient。其中，WebViewClient 主要用来监听通知或请求事件，我们在开发中可能会用到的方法主要是下面几个：</p>
<ul>
<li>onPageStarted</li>
<li>onPageFinished</li>
<li>onReceivedError</li>
<li>shouldOverrideUrlLoading</li>
</ul>
<p>而 <code>WebChromeClient</code> 则用来处理javascript、网站图标、网站title和加载进度等，我们在使用微信时，如果打开一个网页，会看到它的上面有一条绿色的进度条，这个功能就是通过重写 <code>WebChromeClient</code> 的 <code>onProgressChanged</code>方法来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWebClient</span> <span class="keyword">extends</span> <span class="title">WebChromeClient</span> </span>&#123; </div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(WebView view, <span class="keyword">int</span> newProgress)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (newProgress == <span class="number">100</span>) &#123; </div><div class="line">            mProgressBar.setVisibility(GONE); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">if</span> (mProgressBar.getVisibility() == GONE) &#123; </div><div class="line">                mProgressBar.setVisibility(VISIBLE); </div><div class="line">            &#125; </div><div class="line">            mProgressBar.setProgress(newProgress);</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">super</span>.onProgressChanged(view, newProgress); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除此之外，WebView还提供了直接运行javascript的功能，例如，我们可以简单的弹出一个对话框：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.loadUrl(<span class="string">"javascript:alert(\"提示信息！\");"</span>);</div></pre></td></tr></table></figure>
<p>当然，如果我们想要执行js，那么必须满足两个条件，第一个是在设置中开启javascript支持，即需要调用<code>setJavascriptEnabled(true)</code>，第二个是需要设置<code>WebChromeClient</code>，两者缺一不可。</p>
<p>在一些比较复杂的场景下，我们要做的不再是简单的显示一个页面而已，大多时候，我们更希望通过javascript来访问app内的一些数据，或者与app进行交互。我们尝试定义这样一个组件，希望可以通过它来达到我们的目的，我们暂且对这样的组件起名为<code>WebViewJavascriptBridge</code>。</p>
<h2 id="WebViewJavascriptBridge设计思路"><a href="#WebViewJavascriptBridge设计思路" class="headerlink" title="WebViewJavascriptBridge设计思路"></a>WebViewJavascriptBridge设计思路</h2><p>根据第二节的介绍，对于第一种情况，也就是通过java来调用javascript代码，系统已经帮我们实现好了，但是第二种情况系统却没有直接提供实现。 尽管如此，我们可以考虑是否能在 <code>WebViewClient</code> 或 <code>WebChromeClient</code> 中寻得突破口。在 <code>WebViewClient</code> 中存在这样一个方法: <code>shouldOverrideUrlLoading(WebView view, String url)</code>，在这个方法的注释中是这样说的：</p>
<blockquote>
<p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView.</p>
</blockquote>
<p>也就是说，对于在WebView中的每个请求，我们都是有机会对其进行拦截的，并且接管本次请求。 我们比较熟悉的是通过一个url来访问页面，比如我们在访问美团网的时候，它的一个团购单的url可能是这个样子 <code>http://bj.meituan.com/deal/25709595.html</code>，而url本身是可以携带一些信息的，上面这个url还不是很明显，如果我们换种写法，你就会看的更清楚些 <code>http://bj.meituan.com/?deal=25709595</code>当然这个链接并不能正常访问到团购页，这里只是做个示意，也就是说我们是可以通过这种param的形式来传递一些数据的。 而我们又可以在 <code>WebViewClient</code> 中对这个请求进行拦截，在拦截方法中我们是能够拿到本次请求的url中所传递过来的数据的，根据这些请求过来的数据，就可以执行本地java代码来处理了，处理完毕后，通过WebView又可以通过回调javascript的方式来返回结果。 以上就是我们实现 <code>WebViewJavascriptBridge</code> 的主要思路了，当然在具体实现的时候会有一些细节，这个我们在下一节具体实现的时候再继续探讨。<br>总结一下，1、java调用javascript可以直接调用。2、javascript调用java需要用到 <code>WebViewClient</code>。我们用下图更直观的表示下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2368004-9ab4b678dc70ba52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java与javascript交互示意.jpg"></p>
<h2 id="WebViewJavascriptBridge具体实现"><a href="#WebViewJavascriptBridge具体实现" class="headerlink" title="WebViewJavascriptBridge具体实现"></a>WebViewJavascriptBridge具体实现</h2><p>我们知道，一个标准的URL的格式应该是下面这个样子：</p>
<blockquote>
<p>protocol://hostname[:port]/path/[;parameters][?query]#fragment</p>
</blockquote>
<p>我们在访问页面的时候，用到的最多的协议就是<code>http</code>和<code>https</code>了，除了这两个协议外，还有<code>file</code>、<code>ftp</code>等等。这里我们自己来定义一个协议名称，所有javascript调用java的代码都走这个协议。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CUSTOM_PROTOCOL_SCHEME = <span class="string">"wvjbscheme"</span>; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCorrectProtocolScheme</span><span class="params">(String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(url)) &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </div><div class="line">        &#125; </div><div class="line">        <span class="keyword">return</span> url.startsWith(CUSTOM_PROTOCOL_SCHEME + <span class="string">"://"</span>);   </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的好处就是，我们在对请求进行拦截后，可以更方便的分辩出哪些是需要自己处理的，而对哪些正常的网络请求放行。因此，我们可以定义一个<code>WebViewClient</code>的子类，并重写它的<code>shouldOverrideUrlLoading</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    <span class="keyword">private</span> WebViewJsBridgeBase base; </div><div class="line">    <span class="keyword">private</span> WebViewClient mWebViewClient; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            url = URLDecoder.decode(url, <span class="string">"UTF-8"</span>); </div><div class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; </div><div class="line">            <span class="comment">// do nothing </span></div><div class="line">        &#125; </div><div class="line">        <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">            ... </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            <span class="keyword">return</span> mWebViewClient.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.shouldOverrideUrlLoading(view, url); </div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，我们会去判断是否是我们自定义的协议，如果不是还会判断mWebViewClient是否为空，这里为什么还要定义一个WebViewClient呢？原因也很简单，<code>WebView</code>只能设置一个<code>WebViewClient</code>，我们这里已经定义了<code>WebViewClient</code>如果用户还需要自己定义怎么办呢？所以这里持有了一个用户自定义的<code>WebViewClient</code>，通过这个client就可以将一些事件转发出去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView view, String url, Bitmap favicon)</span> </span>&#123; </div><div class="line">        <span class="keyword">if</span> (mWebViewClient != <span class="keyword">null</span>) &#123; </div><div class="line">            mWebViewClient.onPageStarted(view, url, favicon); </div><div class="line">        &#125; <span class="keyword">else</span> &#123; </div><div class="line">            <span class="keyword">super</span>.onPageStarted(view, url, favicon); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，我们回到Bridge的实现问题上来。在一个页面加载完毕后，如果我们想使用javascript来调用java，那么前期的一些准备工作是必不可少的，因为我们这里说的javascript调用java并不是将javascript代码转化为java执行，而更像是一种曲线救国的方式，因此，至少我们要约定一下，javascript的哪个方法可以调用java对应的哪个方法，也就是我们对其进行一些初始化操作。</p>
<p>我们将java可以处理的每个问题抽象为一个Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBHandler</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>WVJBResponseCallback</code>也是一个接口，当<code>Handler</code>处理完毕后就是通过这个<code>callback</code>来进行回调给javascript端的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WVJBResponseCallback</span> </span>&#123; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(String responseData)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在我们定义的这两个接口里面，数据是按照String的格式进行传输的，因为javascript天生支持json，因此，对于一些复杂的数据类型，都可以转化为json字符串。</p>
<p>我们的初始化操作就包括注册这些Handler，也就是声明java端可以处理哪些问题，因为会有多个Handler，也就会有多个Callback：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridgeBase</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    Map&lt;String, WVJBResponseCallback&gt; responseCallbacks; </div><div class="line">    Map&lt;String, WVJBHandler&gt; messageHandlers; </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewJsBridge</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerHandler</span><span class="params">(String handlerName, WVJBHandler handler)</span> </span>&#123; </div><div class="line">        base.messageHandlers.put(handlerName, handler); </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到目前为止，我们一直都是在讲java端的一些实现，那在js端到底要怎么样才能调用我们定义好的Handler呢？</p>
<p>通过上面的介绍，如果希望调用java代码，那么必须发起一个请求，在页面中我们发起请求的方式有几种，最常规的是点击一个链接进行跳转，还可以通过javascript来发起一个ajax请求，除此之外，我们还可以借助iframe，就像下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">WVJBIframe.style.display = <span class="string">'none'</span>;</div><div class="line">WVJBIframe.src = <span class="string">'wvjbscheme://__BRIDGE_LOADED__'</span>;</div><div class="line"><span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</div></pre></td></tr></table></figure>
<p>我们在原页面里面添加了一个隐藏的iframe元素，所有需要跟java交互的请求都是通过改变这个iframe的src属性来实现的。</p>
<p>假设说我们现在需要实现一个功能，是在页面里有一个分享按钮，点击这个分享按钮后，打开app自己的分享功能。</p>
<p>第一步，我们需要实现这样一个Handler ，并且将其注册到Bridge中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bridge.registerHandler(<span class="string">"share_handler"</span>, <span class="keyword">new</span> WVJBHandler() &#123;   </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String data, WVJBResponseCallback callback)</span> </span>&#123; </div><div class="line">        Log.d(<span class="string">"share info from js : "</span>, data); </div><div class="line">        callback.callback(<span class="string">"share success"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第二步，在js中，我们通过一个<code>callHandler</code>方法来请求java代码的执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">'function'</span>) &#123; </div><div class="line">        responseCallback = data; </div><div class="line">        data = <span class="literal">null</span>; </div><div class="line">    &#125; </div><div class="line">    _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_doSend</span>(<span class="params">message, responseCallback</span>) </span>&#123; </div><div class="line">    <span class="keyword">if</span> (responseCallback) &#123; </div><div class="line">        <span class="keyword">var</span> callbackId = <span class="string">'cb_'</span>+(uniqueId++)+<span class="string">'_'</span>+<span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </div><div class="line">        responseCallbacks[callbackId] = responseCallback; </div><div class="line">        message[<span class="string">'callbackId'</span>] = callbackId; </div><div class="line">    &#125; </div><div class="line">    sendMessageQueue.push(message); </div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + QUEUE_HAS_MESSAGE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们在这里构造了一个Message对象，这个对象包含三个属性，一个是需要java处理的Handler名称，一个是data数据本身，还有是一个回调方法的id，这个回调方法就是java在执行完毕后的回调方法。此外，我们提供了一个Queue来保存这些请求的Message对象，之后通知java有Message进入到队列里面。<br>第三步，<code>WebViewClient</code>对这个请求进行拦截，并到javascript的queue中去取Message：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean shouldOverrideUrlLoading(WebView view, <span class="built_in">String</span> url) &#123; </div><div class="line">    ... </div><div class="line">    if (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        if (base.isQueueMessageUrl(url)) &#123; </div><div class="line">            <span class="built_in">String</span> javascriptCommand = base.javascriptFetchQueryCommand(); </div><div class="line">            bridge.evaluateJavascript(javascriptCommand); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        return <span class="literal">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于在Android中执行javascript后不会反回结果，所以为了拿到Message对象，我们需要将这个Message对象像参数一样附在请求的后面传递给java：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">_fetchQueue</span>(<span class="params"></span>) </span>&#123; </div><div class="line">    <span class="keyword">var</span> messageQueueString = <span class="built_in">JSON</span>.stringify(sendMessageQueue); </div><div class="line">    sendMessageQueue = []; </div><div class="line">    <span class="comment">// android 不能直接返回结果,做在放在url中返回 </span></div><div class="line">    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="string">'://'</span> + RETURN_WITH_MESSAGE + <span class="string">'/'</span> + messageQueueString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，这个请求会再次被<code>WebViewClient</code>拦截，并解析<code>Message</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123; </div><div class="line">    ... </div><div class="line">    <span class="keyword">if</span> (base.isCorrectProtocolScheme(url)) &#123; </div><div class="line">        ... </div><div class="line">        <span class="keyword">if</span> (base.isReturnMessageUrl(url)) &#123; </div><div class="line">            String messageQueueString = base.messageQueueStringFromReturnUrl(url); </div><div class="line">            base.flushMessageQueue(messageQueueString); </div><div class="line">        &#125; </div><div class="line">        ... </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>flushMessageQueue</code>方法中，主要执行的就是解析Message，并调用对应的Handler来进行处理，在处理完毕后，回调javascript的callback方法返回结果。到此，java与javascript的一个完整的交互流程就完成了。更完整的代码可以参考：<a href="https://github.com/xiaoza/WebViewJavascriptBridgeForAndroid" target="_blank" rel="external">WebViewJavascriptBridgeForAndroid</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/posts/2016-08-30-MongoDB索引.html" class="prev">PREV</a><a href="/posts/2016-06-29-Picasso源码解析.html" class="next">NEXT</a></div><div data-thread-key="posts/2016-07-01-Android中与js进行交互.html" data-title="Android中与js进行交互" data-url="http://iszhenyu.me/posts/2016-07-01-Android中与js进行交互.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"iszhenyu"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://iszhenyu.me">zhenyu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>