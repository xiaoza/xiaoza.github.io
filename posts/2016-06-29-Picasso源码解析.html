<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Picasso源码解析 · zhenyu</title><meta name="description" content="Picasso源码解析 - zhenyu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iszhenyu.me/atom.xml" title="zhenyu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/xiaoza" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Picasso源码解析</h1><div class="post-info">Jun 29, 2016</div><div class="post-content"><p>Picasso作为一个非常棒的android第三方图片加载库，在Github上获得了高达7000多的star。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Picasso.with(context).load(“image url”).into(imageView);</div></pre></td></tr></table></figure>
<p>这么简单的一行代码就完成了在Android中加载图片的功能，这其中，Picasso还帮我们自动完成了一些android中处理图片的问题：例如在adapter中ImageView的回收和取消下载，使用最小的内存来完成图片的过渡，自动的内存和磁盘缓存等，的确是非常简单的。</p>
<p>但作为开发人员，简单的会用是不够的，毕竟我们在实际项目中可能会遇到各种奇葩问题，这个时候就有必要深入到内部一探究竟了。下面就从源码的角度来讲解一下Picasso的工作原理。我们可以直接在github上 clone下整个Picasso项目或者如果你使用的是studio的gradle依赖管理，那么也可以直接在项目的Extension Library中查看Picasso的源码。</p>
<p>我们先看下上面一行代码中用到的三个函数，首先是with函数，它的实现是这个样子的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Picasso <span class="title">with</span><span class="params">(Content context)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">synchronized</span> (Picasso.class) &#123;</div><div class="line">               <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</div><div class="line">                    singleton = <span class="keyword">new</span> Builder().build();</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> singleton;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">可以看到Picasso使用的是单例模式，并且使用Builder模式创建了一个Picasso的实例，具体如何创建的我们这里先不管，继续往下看。</div><div class="line">有了这个的实例之后，直接调用了它的load函数，Picasso重载了几个不同参数的load函数，用以从不同的地点来加载图片：</div><div class="line">```<span class="function">java</span></div><div class="line"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(Uri uri)</span> &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> RequestCreator <span class="title">load</span><span class="params">(<span class="keyword">int</span> resourceId)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过load函数，我们最终得到了一个RequestCreator对象，通过这个对象我们就可以定制一些对图片的特殊处理了，这里我们同样不去深究这个RequestCreator内部是如果对图片进行处理的。<br>最后我们调用了into函数，将加载到的图片赋给一个ImageView控件。我们前面的操作可以说都是为into函数做准备，实际工作的开始，就是在into里面完成的。我们跟进<code>into</code>方法看一下，当然了，我们现在还是主要关注流程，不必过于深究细节，这个方法稍微有点长，但是为了方便起见，我们把它的代码贴在这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">into</span><span class="params">(Target target)</span> </span>&#123;</div><div class="line">    <span class="keyword">long</span> started = System.nanoTime();</div><div class="line">    checkMain();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Target must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (deferred) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fit cannot be used with a Target."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!data.hasImage()) &#123;</div><div class="line">        picasso.cancelRequest(target);</div><div class="line">        target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Request request = createRequest(started);</div><div class="line">    String requestKey = createKey(request);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldReadFromMemoryCache(memoryPolicy)) &#123;</div><div class="line">        Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);</div><div class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</div><div class="line">            picasso.cancelRequest(target);</div><div class="line">            target.onBitmapLoaded(bitmap, MEMORY);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    Action action =</div><div class="line">        <span class="keyword">new</span> TargetAction(picasso, target, request, memoryPolicy, networkPolicy, errorDrawable,</div><div class="line">            requestKey, tag, errorResId);</div><div class="line">    picasso.enqueueAndSubmit(action);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法稍微有些长，但是逻辑还是比较清晰的，我们总结一下：</p>
<ol>
<li>into会检查当前是否是在主线程上执行。</li>
<li>如果我们没有提供一个图片资源并且有设置placeholder，那么就会把我们设置的placeholder显示出来，并中断执行。</li>
<li>defered属性我们一般情况下不需要关注，只有当我们调用了RequestCreator的fit方法时defered才为true，但我们几乎不会这样做。</li>
<li>接下来就是创建了一个Request对象，我们在前面做得一些设置都会被封装到这个Request对象里面。</li>
<li>检查我们要显示的图片是否可以直接在缓存中获取，如果有就直接显示出来好了。</li>
<li>缓存没命中，那就只能费点事把源图片down下来了。这个过程是异步的，并且通过一个Action来完成请求前后的衔接工作。</li>
</ol>
<p>至此，Picasso在主线程中的工作就结束了。通过上面的分析，我们看到Picasso的思想还是很清晰的：首先通过Picasso创建了一个RequestCreator对象，通过这个对象我们可以针对不同的场景来设置一些属性，之后创建出Request对象，最后通过Action来确定异步请求并对请求结果做处理。</p>
<p>接下来，我们就深入到内部看下具体的执行。首先看下Picasso构造函数的声明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener,</div><div class="line">      RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats,</div><div class="line">      Bitmap.Config defaultBitmapConfig, <span class="keyword">boolean</span> indicatorsEnabled, <span class="keyword">boolean</span> loggingEnabled) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么多的参数，也基本上涵盖了Picasso内部所有重要的组件。同时我们也看到这个Picasso是不允许外部进行实例化的。在这里，Picasso使用了单例和建造者模式来完成Picasso的实例化，在Builder中实例化了Picasso所需要的这些组件，这里使用Builder模式的另一个好处就是可以让我们根据自己的需求来个性化定制组件。那这些组件到底都是做什么的呢，下面我们就一一探个究竟。</p>
<p>既然Picasso是通过Builder来实例化的，那我们就从build函数入手，看一下都做了哪些工作。同样，为了阅读方便，我们把build的代码贴在下面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Picasso <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      Context context = <span class="keyword">this</span>.context;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (downloader == <span class="keyword">null</span>) &#123;</div><div class="line">        downloader = Utils.createDefaultDownloader(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</div><div class="line">        cache = <span class="keyword">new</span> LruCache(context);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</div><div class="line">        service = <span class="keyword">new</span> PicassoExecutorService();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (transformer == <span class="keyword">null</span>) &#123;</div><div class="line">        transformer = RequestTransformer.IDENTITY;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Stats stats = <span class="keyword">new</span> Stats(cache);</div><div class="line"></div><div class="line">      Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher(context, service, HANDLER, downloader, cache, stats);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,</div><div class="line">          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>build结束后，就为Picasso创建了如下几个对象：<br>Downloader、Cache、ExecutorService、RequestTransformer、Stats和Dispatcher，从名称上我们基本上已经能够猜测出来每个组件都是干嘛的。这些对象传递给Picasso的构造函数后，在构造函数的内部又创建了了不同的RequestHandler，用以对不用的图片资源进行加载。说了这么多是不是有点晕，别急，下面我们会对每个组件做介绍，一点点将Picasso的执行过程串起来。</p>
<p>我们先来看下Downloader：它是一个接口，规定了一些通用的方法，这也就意味着，我们可以提供自己的下载器，只要实现这个接口即可，Picasso的扩展能力还是很不错的。这里Picasso默认使用OkHttpClient来作为下载器，同样也是squareup公司开源的一个网络库。</p>
<p>Cache：Picasso的缓存，这里实例化的是LruCache，其内部使用的是LinkedHashMap</p>
<p>ExecutorService：这里Picasso实现了自己的PicassoExecutorService，它继承了ThreadPoolExecutor，也就是Picasso自己维护了一个线程池，用于异步加载图片。</p>
<p>RequestTransformer：主要是对RequestCreator创建的Request进行转换，默认对Request对象不做处理。</p>
<p>Stats：这个类只要是维护图片的一些状态</p>
<p>Dispatcher：从名字上就可以判断出来，这个类在这里起到了一个调度器的作用，图片要不要开始下载以及下载后Bitmap的返回都是通过这个调度器来执行的，后面我们会对它进行更加详细的讲解。</p>
<p>对Picasso几个核心类有了大致了解后，我们再来看它到底是如何执行一个异步请求，又是如何将执行结果返回的。<br>通过上面的分析我们知道，RequestCreator在into方法的最后会创建一个Action实例，然后调用Picasso的enqueueAndSubmit方法，而最终是调用了Dispatcher的dispatchSubmit方法，也就是我们前面说的，Dispatcher起到了调度器的作用。在Dispatcher内部，Dispatcher定义了DispatcherThread和DispatcherHandler两个内部类，并在Dispatcher的构造函数中对他们经行了实例化，所有的调度也都是通过handler异步的执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler,</div><div class="line">      Downloader downloader, Cache cache, Stats stats) &#123;</div><div class="line">    <span class="keyword">this</span>.dispatcherThread = <span class="keyword">new</span> DispatcherThread();</div><div class="line">    <span class="keyword">this</span>.dispatcherThread.start();</div><div class="line">    ...</div><div class="line">    <span class="keyword">this</span>.handler = <span class="keyword">new</span> DispatcherHandler(dispatcherThread.getLooper(), <span class="keyword">this</span>);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，我们看到的dispatchSubmit方法就如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchSubmit</span><span class="params">(Action action)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在handler中最终调用了performSubmit方法来触发一个图片的加载，那么我们来看一下这个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performSubmit</span><span class="params">(Action action, <span class="keyword">boolean</span> dismissFailed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pausedTags.contains(action.getTag())) &#123;</div><div class="line">        pausedActions.put(action.getTarget(), action);</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(),</div><div class="line">            <span class="string">"because tag '"</span> + action.getTag() + <span class="string">"' is paused"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BitmapHunter hunter = hunterMap.get(action.getKey());</div><div class="line">    <span class="keyword">if</span> (hunter != <span class="keyword">null</span>) &#123;</div><div class="line">        hunter.attach(action);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (service.isShutdown()) &#123;</div><div class="line">        <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">            log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), <span class="string">"because shut down"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    hunter = forRequest(action.getPicasso(), <span class="keyword">this</span>, cache, stats, action);</div><div class="line">    hunter.future = service.submit(hunter);</div><div class="line">    hunterMap.put(action.getKey(), hunter);</div><div class="line">    <span class="keyword">if</span> (dismissFailed) &#123;</div><div class="line">        failedActions.remove(action.getTarget());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action.getPicasso().loggingEnabled) &#123;</div><div class="line">        log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法并不发杂，主要是获得BitmapHunter实例，由这个实例来执行实际的下载操作。BitmapHunter本身是Runnable的一个实现，而这个实例最终是交由Picasso线程池进行运行的。</p>
<p>那么这个BitmapHunter加载图片完成或失败后是怎么通知UI的呢？我们前面提到Dispatcher在Picasso中起到了一个调度器的作用，当图片加载完毕后自然也是通过这个调度器来更新UI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        updateThreadName(data);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (picasso.loggingEnabled) &#123;</div><div class="line">            log(OWNER_HUNTER, VERB_EXECUTING, getLogIdsForHunter(<span class="keyword">this</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = hunt();</div><div class="line">        <span class="comment">// 通过Dispatcher来处理结果</span></div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            dispatcher.dispatchFailed(<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            dispatcher.dispatchComplete(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span>() &#123; </div><div class="line">        <span class="comment">//各种异常处理</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>假如我们的图片成功下载下来了，接下来就看看这个图片是如何被渲染到ImageView中的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样通过handler来发送一个message，我们再看消息处理函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_COMPLETE: &#123;</div><div class="line">          BitmapHunter hunter = (BitmapHunter) msg.obj;</div><div class="line">          dispatcher.performComplete(hunter);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们最终执行了performComplete方法。在这个方法了会自动处理图片的缓存问题，方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performComplete</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) &#123;</div><div class="line">      cache.set(hunter.getKey(), hunter.getResult());</div><div class="line">    &#125;</div><div class="line">    hunterMap.remove(hunter.getKey());</div><div class="line">    batch(hunter);</div><div class="line">    <span class="keyword">if</span> (hunter.getPicasso().loggingEnabled) &#123;</div><div class="line">      log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), <span class="string">"for completion"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，Picasso并不是立即将图片显示出来，而是用到了一个批处理，其实就是把操作先暂存在一个list中，等空闲的时候再拿出来处理，这样做得好处也是尽量减少主线程的执行时间，一方面防止ANR，另一方面快速返回，响应页面的其他渲染操作，防止卡顿用户界面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">batch</span><span class="params">(BitmapHunter hunter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (hunter.isCancelled()) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    batch.add(hunter);</div><div class="line">    <span class="keyword">if</span> (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) &#123;</div><div class="line">      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handMessage中对应的处理方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">final</span> Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">case</span> HUNTER_DELAY_NEXT_BATCH: &#123;</div><div class="line">          dispatcher.performBatchComplete();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，通过这个batch我们实际看到，最后还是调用了Dispatcher的方法来处理，但由于这个处理并非是在主线程（参考前面Dispatcher构造函数中Handler的实例化），因此我们还需要通过一个主线程的Handler来处理这个请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">performBatchComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;BitmapHunter&gt; copy = <span class="keyword">new</span> ArrayList&lt;BitmapHunter&gt;(batch);</div><div class="line">    batch.clear();</div><div class="line">    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));</div><div class="line">    logBatch(copy);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个mainThreadHandler是在Dispatcher实例化时由外部传递进来的，我们在前面的分析中看到，Picasso在通过Builder创建时会对Dispatcher进行实例化，在那个地方将主线程的handler传了进来，我们回到Picasso这个类，看到其有一个静态成员变量HANDLER，这样我们也就清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Handler HANDLER = <span class="keyword">new</span> Handler(Looper.getMainLooper()) &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> HUNTER_BATCH_COMPLETE: &#123;</div><div class="line">          <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) List&lt;BitmapHunter&gt; batch = (List&lt;BitmapHunter&gt;) msg.obj;</div><div class="line">          <span class="comment">//noinspection ForLoopReplaceableByForEach</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = batch.size(); i &lt; n; i++) &#123;</div><div class="line">            BitmapHunter hunter = batch.get(i);</div><div class="line">            hunter.picasso.complete(hunter);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>到这里，我们的图片马上就要显示出来了。我们前面提到，Picasso中一个Action提供了请求前后的衔接工作，对于我们现在的情况，Picasso使用了ImageViewAction来进行处理，也就是在ImageViewAction中的complete方法完成了最后的图片渲染工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(Bitmap result, Picasso.LoadedFrom from)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(</div><div class="line">          String.format(<span class="string">"Attempted to complete action with no result!\n%s"</span>, <span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ImageView target = <span class="keyword">this</span>.target.get();</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Context context = picasso.context;</div><div class="line">    <span class="keyword">boolean</span> indicatorsEnabled = picasso.indicatorsEnabled;</div><div class="line">    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">      callback.onSuccess();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，到此，一个图片从开始下载到成功渲染到ImageView中整个流程就讲完了。其中，Dispatcher那块的调度有点绕，如果不是很理解，可以先熟悉下android中handler的用法，handler本身也是android提供给我们方便进行线程间通信的，就像Picasso的实现一样，善用handler可以帮助我们实现更加流畅的用户UI操作体验。 </p>
</div></article></div></section><footer><div class="paginator"><a href="/posts/2016-08-30-MongoDB索引.html" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://iszhenyu.me">zhenyu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>