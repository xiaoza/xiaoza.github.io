<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 当我们在使用Flask时，如何如记录日志 · zhenyu</title><meta name="description" content="当我们在使用Flask时，如何如记录日志 - zhenyu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://iszhenyu.me/atom.xml" title="zhenyu"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/iszhenyu" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">当我们在使用Flask时，如何如记录日志</h1><div class="post-info">Jan 25, 2017</div><div class="post-content"><p>我们在开发基于Flask的Web应用时，往往容易忽略了对日志的使用，而在Flask的官方文档中，对日志这块的介绍也仅仅停留在如何与系统集成上。记录日志这个看似很简单的事情，在实际中很多人却不一定能做好，要么不知道何时进行日志记录，要么就是记录的日志然并卵。所以，今天就来说说记录日志这件小事。</p>
<p>说它是件小事，因为它的确不会影响你系统的正常流程，有没有它系统都能跑起来，也正因为这样，很多人便忽略了日志的处理，或者干脆都没有配置日志输出，整个系统没有任何日志输出（Nginx日志不算）。当然，如果是我们自己开发的一些小网站，大家用来练练手或着用户量不大，有没有日志都一样，但是对于一些大型的系统，它的用户是很多的，在任何一个环节都可能出问题，为了能够及时的定位问题和监控系统运行状态，正确合理的记录日志就非常非常重要了。一般情况下，我们需要关注的是三个方面的内容：</p>
<ul>
<li>日志信息的集中采集、存储和检索：这个主要是在多节点的情况下如何方便的查看日志信息。</li>
<li>日志信息的输出策略：要保证日志输出的全面而又不显凌乱，方便开发人员跟踪和分析问题。</li>
<li>关键业务的日志输出：我们常说的<code>打点</code>就属于这个范畴，比如我们的一些浏览记录等，这个就需要根据业务要求来做针对性设计了。</li>
</ul>
<p>我们在这里主要是围绕第二个问题来展开，也是我们开发人员最直接接触的情况。</p>
<h2 id="日志输出级别"><a href="#日志输出级别" class="headerlink" title="日志输出级别"></a>日志输出级别</h2><p>从Flask 0.3 版本开始，系统就已经帮我们预配置了一个logger，而这个logger的使用也是非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.logger.debug(&apos;A value for debugging&apos;)</div><div class="line">app.logger.warning(&apos;A warning occurred (%d apples)&apos;, 42)</div><div class="line">app.logger.error(&apos;An error occurred&apos;)</div></pre></td></tr></table></figure>
<p>其中的app就是Flask的实例，而这个app.logger也就是一个标准的logging Logger，因此，我们在使用app.logger时可选择的输出级别与python logging中的定义是一致的。</p>
<ul>
<li><code>ERROR</code>：这个级别的日志意味着系统中发生了非常严重的问题，必须有人马上处理，比如数据库不可用了，系统的关键业务流程走不下去了等等。很多人在实际开发的时候，不会去区分问题的重要程度，只要有问题就error记录下来，其实这样是非常不负责任的，因为对于成熟的系统，都会有一套完整的报错机制，那这个错误信息什么时候需要发出来，很多都是依据单位时间内error日志的数量来确定的。因此如果我们不分轻重缓急，一律error对待，就会徒增报错的频率，久而久之，我们的救火队员对错误警报就不会那么在意，这个警报也就失去了原始的意义。</li>
<li><code>WARN</code>：发生这个级别的问题时，处理过程可以继续，但必须要对这个问题给予额外的关注。假设我们现在有一个系统，希望用户每一个月更换一次密码，而到期后，如果用户没有更新密码我们还要让用户可以继续登录，这种情况下，我们在记录日志时就需要使用WARN级别了，也就是允许这种情况存在，但必须及时做跟踪检查。</li>
<li><code>INFO</code>：这个级别的日志我们用的也是比较多，它一般的使用场景是重要的业务处理已经结束，我们通过这些INFO级别的日志信息，可以很快的了解应用正在做什么。我们以在12306上买火车票为例，对每一张票对应一个INFO信息描述“[who] booked ticket from [where] to [where]”。</li>
<li><code>DEBUG</code>和<code>TRACE</code>：我们把这两个级别放在一起说，是应为这两个级别的日志是只限于开发人员使用的，用来在开发过程中进行调试，但是其实我们有时候很难将DEBUG和TRACE区分开来，一般情况下，我们使用DEBUG足以。</li>
</ul>
<p>以上就是我们实际开发中最多接触的几种日志级别，基本能覆盖99%的情况。最后我们要注意的就是，最好能尽可能输出更多的日志信息，并且不做任何过滤，同时输出的每一条日志的详细信息要切当，让我们可以快速过滤并找到所需的信息。</p>
<h2 id="日志输出信息"><a href="#日志输出信息" class="headerlink" title="日志输出信息"></a>日志输出信息</h2><p>当我们确定了使用哪个级别来写入日志后，下一步要做的就是确定要记录什么样的信息。针对这一块的内容，其实又可以细分。</p>
<h3 id="日志应该记录什么"><a href="#日志应该记录什么" class="headerlink" title="日志应该记录什么"></a>日志应该记录什么</h3><p>一般来说，日志的记录要满足几个要求：可读、干净、详细和自描述。我们先来看几个反模式的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.logger.debug(&apos;message processed&apos;)</div><div class="line">app.logger.debug(message.get_message_id())</div><div class="line">app.logger.debug(&apos;message with id %s&apos;, message.get_message_id())</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if isinstance(message, TextMessage):</div><div class="line">    ...</div><div class="line">else:</div><div class="line">    app.logger.warn(&apos;unknow message type&apos;)</div></pre></td></tr></table></figure>
<p>上面列出的这几个例子，问题在什么地方呢？当看到这些日志信息后，我们首先意识到的肯定是哪里出了问题，但是，这个问题产生的原因是什么我们并不清楚，也就是说，只根据这样的日志我们是没办法对问题进行修复的。所以我们在记录日志的时候，应该要尽量的详细，日志的上下文要交代清楚。</p>
<p>另外一种反模式的日志信息，我们通常叫做魔法日志。就比如说，有的开发人员为了自己查找信息方便，会输出一些类似<code>&amp;&amp;&amp;###&gt;&gt;&gt;&gt;&gt;&gt;</code>的日志，这些特殊的符号只有开发者本人清楚到底是做什么的，而对其他人来说，看到这些日志绝对是一脸懵逼。即使是开发者本人，哪怕当时能够清楚这些魔法日志的特殊含义，但时间一长，估计他们也很难回想起当时为啥要输出这些鬼东西了吧。</p>
<p>其次，还有一种是要关注外部系统，也就是在和任何外部系统通信的时候，建议记录所有进出系统的数据。但是，记录这些信息时，性能是一个比较头痛的问题，有时，需要和外部系统交换的信息量太大，导致无法记录所有信息。但是，在调试或测试期间我们还是愿意记录所有信息，并准备为此付出一些性能的代价，这个可以通过仔细控制log级别来实现，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if app.config[&apos;debug&apos;]:</div><div class="line">    app.logger.debug(&apos;...&apos;)</div><div class="line">else:</div><div class="line">    app.logger.info(&apos;...&apos;)</div></pre></td></tr></table></figure>
<p>最后要提的一点就是，我们输出的这些日志信息中，绝对不可以透露系统密码和一些个人信息。</p>
<h3 id="如何打印日志内容"><a href="#如何打印日志内容" class="headerlink" title="如何打印日志内容"></a>如何打印日志内容</h3><p>当我们明确了该用哪个级别去记录哪些信息后，就要把这些信息输出到日志文件中，但是想正确高效的打印日志内容也并非一件简单的事。Flask已经帮我们预配置了一个logger，我们可以使用这个logger来完成我们所有的打印操作。</p>
<blockquote>
<p>我们在记录日志的时候绝对不可以使用<code>print</code>，即使我们在开发调试的时候能够在控制台看到打印的信息，但是这样的信息并不会记录到日志文件中，当我们的程序上线后，跟没有记录日志的效果是一样的。因此，哪怕是在开发调试时，也要尽量使用logger。</p>
</blockquote>
<p>最简单的日志打印就是输出一个字符串，比如像下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.logger.info(&apos;this is a string&apos;)</div></pre></td></tr></table></figure>
<p>但大部分时候，我们要记录的信息都会包含一些参数，有一种实现方式是提前构造出这个字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">message_info = &apos;the message is %s&apos; % info</div><div class="line">app.logger.info(message_info)</div></pre></td></tr></table></figure>
<p>这种写法也没啥问题，但其实，logger内部也可以帮助我们完成上面的操作，也就是我们还可以写成下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">app.logger.info(&apos;the message if %s&apos;, info)</div></pre></td></tr></table></figure>
<p>这样看起来是不是简洁了好多呢？</p>
<h2 id="记录异常信息"><a href="#记录异常信息" class="headerlink" title="记录异常信息"></a>记录异常信息</h2><p>记录异常信息严格来说也应该算到日志输出的范畴，之所以把它拿出来单独说，是因为除了说明应该怎样去记录异常外，这里还要说下如何去自定义异常。</p>
<h3 id="正确的记录异常信息"><a href="#正确的记录异常信息" class="headerlink" title="正确的记录异常信息"></a>正确的记录异常信息</h3><p>对于异常，我们更想看到的其实是它的堆栈信息，而不是简单的一句话，堆栈信息可以帮助我们快速的定位问题出处。如果想打印堆栈，我们前面的记录方法就不再实用了，哪怕我们把<code>Exception</code>的实例丢到logger里打印出来的也仅仅是错误信息而不是堆栈信息。比如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3]</div><div class="line">try:</div><div class="line">    print a[3]</div><div class="line">except Exception, e:</div><div class="line">    logging.error(e)</div></pre></td></tr></table></figure>
<p>如果我们查看日志，发现打印出的仅仅是一行错误信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Tue, 24 Jan 2017 16:07:20 demo.py[line:22] ERROR list index out of range</div></pre></td></tr></table></figure>
<p>那如何打印出堆栈信息呢？python给我们提供了一个<code>exception</code>方法，它的使用跟<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>几个方法是一样的，我们可以把上面的代码修改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a = [1, 2, 3]</div><div class="line">try:</div><div class="line">    print a[3]</div><div class="line">except Exception, e:</div><div class="line">    logging.exception(e)</div></pre></td></tr></table></figure>
<p>之后我们再看日志输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Tue, 24 Jan 2017 17:19:37 demo.py[line:22] ERROR list index out of range</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/Users/xiaoz/developments/python/ttest/demo.py&quot;, line 20, in test</div><div class="line">    print a[3]</div><div class="line">IndexError: list index out of range</div></pre></td></tr></table></figure>
<p>除了我们上面使用<code>error</code>方法打印的错误信息外，还打印出了出错的堆栈信息，由此看见，<code>exception</code>方法打印的日志会包含两项，第一项就是调用<code>exception</code>方法时传入的message，还有一项是紧跟在message后面的堆栈信息。</p>
<blockquote>
<p>当我们使用<code>exception</code>方法时，它记录的日志级别为<code>ERROR</code>，如果我们希望打印出堆栈信息，同时又不希望使用<code>ERROR</code>这个级别怎么办呢？如果你查看<code>exception</code>方法的实现，会发现，它只是多加了一行代码<code>kwargs[&#39;exc_info&#39;] = 1</code>，然后调用了<code>error</code>方法，以此类推，如果我们希望打印堆栈信息就可以像下面这样写：<code>app.logger.info(&#39;message info is %s&#39;, message, exc_info=1)</code>。</p>
</blockquote>
<p>Flask允许我们自定义对异常的处理，一般情况下，我们会做一些统一处理，比如下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@app.errorhandler(500)</div><div class="line">def internal_server_error(e):</div><div class="line">    app.logger.exception(&apos;error 500: %s&apos;, e)</div><div class="line">    response = json_error(&apos;internal server error&apos;)</div><div class="line">    response.status_code = 500</div><div class="line">    return response</div></pre></td></tr></table></figure>
<p>我们在返回结果的同时，对错误信息进行了记录处理，这样做也是为了避免模板代码，减少开发人员的工作量。但是，在减少我们开发量的同时，这也意味着可能会带来另外一个问题，很多程序员喜欢捕获异常后将错误写入日志，然后再将异常包装后重新抛出，这样会重复打印日志信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">... some thing ...</div><div class="line">try:</div><div class="line">    ... do some thing ...</div><div class="line">except Exception, e:</div><div class="line">    app.logger.error(e)</div><div class="line">    raise SomeException(e)</div></pre></td></tr></table></figure>
<p>还有一种情况，如果我们在捕获异常的时候，不分情况统一捕获<code>Exception</code>也是不对的。直接捕获<code>Exception</code>固然方便，但是我们捕获的范围太大的话，有的时候会吃掉关键的信息，而这些被吃掉的异常又没有打印错误信息和堆栈，一旦有问题，是很难排查的，比如我们定义了下面的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def some_method():</div><div class="line">    .. do some thing ..</div><div class="line">    try:</div><div class="line">        .. do dome thing 2 ..</div><div class="line">        return True</div><div class="line">    except Exception, e:</div><div class="line">        return False</div></pre></td></tr></table></figure>
<p>当<code>do some thing 2</code>中发生异常时，我们是没法察觉到的，这样不但会使方法返回不正确，也会给排查带来困难。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>首先，我们看看为什么要自定义异常，在需要抛出异常的地方，我们直接<code>raise Exception()</code>不好吗？答案很显然，肯定是不好，具体的原因，我们下面就逐条分析下。</p>
<ol>
<li>大多时候我们都是使用json来为不同端提供接口支持，不管成功与否，都必须使用统一的数据格式。如果系统充斥着各种异常就很难做到统一。</li>
<li>要能反映出该异常的重要程度，比如：如果是参数校验异常则被认为不是很重要，可能直接记下warn日志就行了，而orm异常必须要记录error日志。</li>
<li>最后，对于异常的信息要有区分，比如，对于orm异常，我们希望给用户看到的是一条简单的系统出错的提示信息，而我们在查看日志时必须要有详细的异常信息。</li>
</ol>
<p>为了解决上面的问题，需要我们来自定义异常，并且使用的时候也尽量要使用已定义的异常类。这里我们来看一种实现方式，大家可以参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">class BaseError(Exception):</div><div class="line"></div><div class="line">    default_status_code = 200</div><div class="line"></div><div class="line">    LEVEL_DEBUG = 0</div><div class="line">    LEVEL_INFO = 1</div><div class="line">    LEVEL_WARN = 2</div><div class="line">    LEVEL_ERROR = 3</div><div class="line"></div><div class="line">    def __init__(self, message, status_code=None, extras=None, parent_error=None):</div><div class="line">        self._message = message</div><div class="line">        self._code = status_code</div><div class="line">        self.extras = extras</div><div class="line">        self.parent_error = parent_error</div><div class="line">        self.level = BaseError.LEVEL_DEBUG</div><div class="line"></div><div class="line">    @property</div><div class="line">    def status_code(self):</div><div class="line">        if not self._code:</div><div class="line">            return BaseError.default_status_code</div><div class="line">        return self._code</div><div class="line"></div><div class="line">    def to_dict(self):</div><div class="line">        rv = &#123;</div><div class="line">            &apos;error_message&apos;: self._message,</div><div class="line">            &apos;status_code&apos;: self.status_code,</div><div class="line">            &apos;success&apos;: False</div><div class="line">        &#125;</div><div class="line">        return rv</div><div class="line"></div><div class="line"></div><div class="line">class ValidationError(BaseError):</div><div class="line">    def __init__(self, message, extras=None):</div><div class="line">        super(ValidationError, self).__init__(message=message, extras=extras)</div><div class="line">        self.level = BaseError.LEVEL_INFO</div><div class="line"></div><div class="line"></div><div class="line">class NotFoundError(BaseError):</div><div class="line">    def __init__(self, message, extras=None):</div><div class="line">        super(NotFoundError, self).__init__(message=message, extras=extras)</div><div class="line">        self.level = BaseError.LEVEL_WARN</div><div class="line"></div><div class="line"></div><div class="line">class FormError(BaseError):</div><div class="line">    def __init__(self, form):</div><div class="line">        message = form.get_validate_error()</div><div class="line">        super(FormError, self).__init__(message, extras=form.data)</div><div class="line">        self.level = BaseError.LEVEL_INFO</div><div class="line"></div><div class="line"></div><div class="line">class OrmError(BaseError):</div><div class="line">    def __init__(self, message, status_code=None, extras=None, parent_error=None):</div><div class="line">        super(OrmError, self).__init__(message, status_code, extras, parent_error)</div><div class="line">        self.level = BaseError.LEVEL_ERROR</div></pre></td></tr></table></figure>
<p>定义了上面的异常信息后，我们在统一处理错误信息的时候就可以像下面这样实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@app.errorhandler(BaseError)</div><div class="line">def custom_error_handler(e):</div><div class="line">    if e.level in [BaseError.LEVEL_WARN, BaseError.LEVEL_ERROR]:</div><div class="line">        if isinstance(e, OrmError):</div><div class="line">            app.logger.exception(&apos;%s %s&apos; % (e.parent_error, e))</div><div class="line">        else:</div><div class="line">            app.logger.exception(&apos;错误信息: %s %s&apos; % (e.extras, e))</div><div class="line">    response = jsonify(e.to_dict())</div><div class="line">    response.status_code = e.status_code</div><div class="line">    return response</div></pre></td></tr></table></figure>
<p>如此，就兼顾了日志的错误级别和接口返回的数据格式。</p>
<h2 id="我们还应该注意什么"><a href="#我们还应该注意什么" class="headerlink" title="我们还应该注意什么"></a>我们还应该注意什么</h2><p>其实，对于日志的记录，我们前面七七八八也讲了个差不多，在开发的时候如果我们能够注意到上面提到的一些问题，已经能够算是比较合格的打日志了。当然，还有一些小的问题，在最后还是要说明一下。</p>
<p>第一个，就是需要我们关键一下性能问题，也就是避免因为日志拖慢应用系统。如果输出的日志信息太多，必然会增加磁盘的写入负担，通常情况下，每小时输出到磁盘的数据量达到几百M就已经是上限了。</p>
<p>第二个，就是不要由于log语句导致业务过程中断。我们的本意是通过日志来记录系统的一些运行信息，但是，log语句本身也是有可能发生异常的，如果因为我们的代码，导致日志记录的时候抛出了异常，就真的是得不偿失了。</p>
<p>OK，关于在Flask系统中如何进行日志记录，就介绍到这了，其实，上面提到的内容不仅在Flask系统中可行，基本上所有的Web系统都有参考价值。大家有什么问题，欢迎交流。</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2017-03-26-基于Flask，构建自己的Web框架.html" class="prev">上一篇</a><a href="/posts/2016-10-13-MongDB索引的介绍及使用.html" class="next">下一篇</a></div><div data-thread-key="posts/2017-01-25-当我们在使用Flask时，如何如记录日志.html" data-title="当我们在使用Flask时，如何如记录日志" data-url="http://iszhenyu.me/posts/2017-01-25-当我们在使用Flask时，如何如记录日志.html" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"iszhenyu"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://iszhenyu.me">zhenyu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-56494721-2",'auto');ga('send','pageview');</script></body></html>